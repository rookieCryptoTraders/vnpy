# Understanding `factor_key` vs. `factor_name`

In this factor analysis framework, two important identifiers are associated with each factor instance: `factor_key` and `factor_name`. They serve distinct purposes and understanding their roles is crucial for configuring and working with factors.

---

## 1. `factor_key`

* **Nature:** Globally Unique Identifier (GUID)
* **Purpose:**
    * The `factor_key` is the **primary, unambiguous identifier** for a specific, unique configuration of a factor. It's how the system distinguishes one factor instance from all others.
    * It is essential for:
        * **Data Storage & Retrieval:** When factor values are calculated and stored (e.g., in `FactorMemory`), they are saved and looked up using the `factor_key`. This ensures that data for `EMA(period=10, freq='1m')` is kept separate and distinct from `EMA(period=20, freq='1m')` or `EMA(period=10, freq='5m')`.
        * **Dependency Resolution:** When one factor (a "parent" factor) depends on the output of another factor (a "child" or "dependency" factor), the parent's configuration refers to the child using the child's unique `factor_key`.
        * **System Integrity:** Guarantees that every distinct factor calculation, with its specific parameters and frequency, is treated as a unique entity throughout the system.
* **Generation:**
    * The `factor_key` is automatically generated by the `FactorTemplate` base class (or a similar mechanism).
    * It's typically a composite string derived from the factor's intrinsic and defining properties:
        1.  **Factor Class Name:** (e.g., `EMAFactor`, `MACDFactor`) - often converted to lowercase for consistency.
        2.  **Calculation Frequency (`freq`):** (e.g., `1m`, `1d`).
        3.  **Specific Parameters (`params`):** (e.g., `period_12`, `fast_period_12-slow_period_26-signal_period_9`). Parameter names and their values are usually sorted alphabetically by parameter name before being included in the key to ensure consistency regardless of the order they are defined in the settings.
    * **Example `factor_key` Format:** `factor.{class_name_lower}.{interval_value}@{param_string}`
        * e.g., `"factor.emafactor.1m@period_12"`
        * e.g., `"factor.macdfactor.1m@fast_period_12-signal_period_9-slow_period_26"`
* **Scope:** Global within the entire factor processing system. Each `factor_key` must be unique.
* **Mutability:** Should be considered immutable once the factor instance is defined by its class, frequency, and parameters. Changing any of these core properties effectively defines a *new* factor, which would result in a *new* `factor_key`.

---

## 2. `factor_name`

* **Nature:** Local Alias, Nickname, or Descriptive Label.
* **Purpose:**
    * Provides a human-readable or context-specific name for a factor instance.
    * Its primary utility is when a factor is used as a **dependency** within another, more complex (parent) factor. The parent factor's configuration can assign a `factor_name` (nickname) to its dependency. This nickname clarifies the *role* of that dependency specifically within the context of the parent factor's logic.
    * For example, a `MACDFactor` depends on two EMA calculations. In the `MACDFactor`'s configuration, these EMA dependencies can be given `factor_name`s like `"fast_ema"` and `"slow_ema"`.
* **Setting:**
    * The `factor_name` is specified in the `setting` dictionary used to initialize a `FactorTemplate` instance.
    * When a factor instance is created (either as a top-level factor or as a dependency), its `self.factor_name` attribute is populated with this value from its specific settings block.
* **Scope:**
    * For a top-level factor (one defined directly in the main list of factor settings, not as a dependency nested within another factor's settings), its `factor_name` serves as a general descriptive label for that instance.
    * When defined for a dependency *within a parent factor's configuration*, its main significance is **local to that parent-child dependency relationship**. The parent factor uses this `factor_name` to understand the role or purpose of that particular dependency.
* **Uniqueness:** **Not guaranteed to be globally unique.**
    * Multiple different factor instances (each having a unique `factor_key`) could potentially be assigned the same `factor_name`. For example, if you have a `factor_name: "BaseEMA"` in the main settings for an `EMA(20)`, and another factor like `BollingerBands` also depends on an `EMA(20)` which it internally nicknames (via `factor_name` in its dependency config) as `"BaseEMA"`, these are distinct concepts. The top-level `factor_name` is for that specific EMA instance; the nickname within `BollingerBands` is local to how `BollingerBands` refers to its dependency.
* **Impact on `factor_key`:** The `factor_name` assigned to a factor **does NOT influence its `factor_key`**. The `factor_key` is always derived from the factor's own class, frequency, and its specific parameters.
    * So, a dependency that is nicknamed `"fast_ema"` (and is an `EMAFactor` with `period=12`) will still have its own unique `factor_key` like `"factor.emafactor.1m@period_12"`.

---

**Analogy:**

Imagine a company's employee database:

* **`factor_key` is like an Employee ID Number:**
    * Unique to each employee (e.g., "EMP00123").
    * Used by HR and payroll systems for all official records and lookups.
    * Guarantees you are always referring to the correct individual.

* **`factor_name` is like a Job Title or a Nickname:**
    * **Job Title (for a dependency):** Within "Project Alpha", employee "EMP00123" might have the `factor_name` (role) "Lead Developer". In "Project Beta", employee "EMP00456" might *also* have the `factor_name` (role) "Lead Developer". The role name is the same, but they are different people (different `factor_key`s) filling that role in different contexts.
    * **Nickname (for a top-level factor):** Employee "EMP00123", whose full name is Robert Paulson, might have a preferred `factor_name` "Bob" for general display or easy reference.

---

**Why the Distinction is Important in the System:**

* **System Integrity & Unambiguous Referencing:** The `factor_key` is fundamental for the system to reliably fetch the correct data for the correct, uniquely defined factor calculation, and to correctly wire up dependencies in the computation graph (e.g., in Dask). Dictionaries like `flattened_factors` (mapping unique factor configurations to their instances) and `dask_tasks` (mapping unique factor configurations to their computation tasks) **must be keyed by `factor_key`**.
* **Modularity & Reusability:** A generic factor class (like `EMAFactor`) can be used to create many different instances (EMA(10), EMA(20), EMA(10) on 5-min bars, etc.), each with its own unique `factor_key`. When these instances are used as dependencies, the parent factor can assign them contextually relevant `factor_name`s (nicknames) for clarity within its own internal logic (e.g., inside its `calculate` method if the `input_data` dictionary were to be keyed by these nicknames, though current consensus is to key `input_data` by `factor_key` as well for consistency).
* **Configuration Clarity:** The `factor_name` field in a factor's setting can provide a human-friendly label, and when used for dependencies, it describes the *role* that dependency plays for its parent, making complex configurations easier to understand.

**In Practice:**

* When the `BacktestEngine` initializes factors, it builds a `flattened_factors` dictionary containing all unique `FactorTemplate` instances. This dictionary is keyed by each instance's `factor_key`.
* When the `FactorCalculator` builds the Dask computation graph:
    * The registry of Dask tasks (`all_created_tasks`) is keyed by `factor_key`.
    * The `input_data` dictionary passed to each factor's `calculate` method is also **keyed by the `factor_key`** of the dependency factors (as per our latest understanding of your preference). This ensures that the `calculate` method uses the same unique identifiers that the rest of the system uses for data and task management. The dependency instance's own `factor_name` attribute (the nickname) is available on the dependency instance itself if needed for logging or other descriptive purposes within the `calculate` method, but it's not used for keying the input data.