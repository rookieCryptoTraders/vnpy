# Auto-generated by factor_generator using polats ta-lib.py
import polars as pl
import polars_talib as plta

from vnpy.factor.template import FactorTemplate
from vnpy.factor.memory import FactorMemory

DEFAULT_DATETIME_COL = "datetime"


class MACDEXT_MACDSIGNAL(FactorTemplate):
    """
    Calculates the MACDEXT_MACDSIGNAL indicator.
    """

    author = "Auto-Generated by FactorGenerator"
    factor_name = "MACDEXT_MACDSIGNAL"

    def __init__(self, setting: dict | None = None, vt_symbols: list[str] | None = None, **kwargs):
        """
        Initializes the MACDEXT_MACDSIGNAL.
        Required parameters: fastperiod, fastmatype, slowperiod, slowmatype, signalperiod, signalmatype
        """
        super().__init__(setting, **kwargs)
        self.vt_symbols: list[str] = vt_symbols if vt_symbols else []

        # --- Parameter Validation and Assignment ---
        if not hasattr(self.params, "fastperiod"): raise ValueError(f"{self.factor_key} requires a 'fastperiod' parameter.")
        try: self.fastperiod = float(self.params.fastperiod)
        except (ValueError, TypeError): self.fastperiod = int(self.params.fastperiod)
        if not hasattr(self.params, "fastmatype"): raise ValueError(f"{self.factor_key} requires a 'fastmatype' parameter.")
        try: self.fastmatype = float(self.params.fastmatype)
        except (ValueError, TypeError): self.fastmatype = int(self.params.fastmatype)
        if not hasattr(self.params, "slowperiod"): raise ValueError(f"{self.factor_key} requires a 'slowperiod' parameter.")
        try: self.slowperiod = float(self.params.slowperiod)
        except (ValueError, TypeError): self.slowperiod = int(self.params.slowperiod)
        if not hasattr(self.params, "slowmatype"): raise ValueError(f"{self.factor_key} requires a 'slowmatype' parameter.")
        try: self.slowmatype = float(self.params.slowmatype)
        except (ValueError, TypeError): self.slowmatype = int(self.params.slowmatype)
        if not hasattr(self.params, "signalperiod"): raise ValueError(f"{self.factor_key} requires a 'signalperiod' parameter.")
        try: self.signalperiod = float(self.params.signalperiod)
        except (ValueError, TypeError): self.signalperiod = int(self.params.signalperiod)
        if not hasattr(self.params, "signalmatype"): raise ValueError(f"{self.factor_key} requires a 'signalmatype' parameter.")
        try: self.signalmatype = float(self.params.signalmatype)
        except (ValueError, TypeError): self.signalmatype = int(self.params.signalmatype)

    def calculate(self, input_data: dict[str, pl.DataFrame], memory: FactorMemory) -> pl.DataFrame:
        """Calculates the indicator by iterating through symbols and executing eagerly."""
        # --- Input Data Validation ---
        if input_data.get("close") is None: return pl.DataFrame(data={}, schema=self.get_output_schema())

        # --- Eager Calculation Loop ---
        df_base = input_data.get("close") or next(iter(input_data.values()))
        symbol_columns = [col for col in df_base.columns if col != DEFAULT_DATETIME_COL]
        if self.vt_symbols:
            symbol_columns = [col for col in symbol_columns if col in self.vt_symbols]

        if not symbol_columns:
            return pl.DataFrame(data={}, schema=self.get_output_schema())

        kwargs = { "fastperiod": self.fastperiod, "fastmatype": self.fastmatype, "slowperiod": self.slowperiod, "slowmatype": self.slowmatype, "signalperiod": self.signalperiod, "signalmatype": self.signalmatype }
        output_series_list = []

        for symbol in symbol_columns:
            # Build the keyword arguments by extracting the pl.Series for this symbol
            # E.g., {'high': input_data['high'][symbol], 'low': input_data['low'][symbol]}
            symbol_inputs = { "real": input_data["close"][symbol] }

            # Execute the calculation immediately for this single symbol
            result_series_or_struct = plta.macdext(**symbol_inputs, **kwargs)

            # If this is a component of a multi-output function, extract the field.
            if "macdsignal":
                final_series = result_series_or_struct.struct.field("macdsignal")
            else:
                final_series = result_series_or_struct

            output_series_list.append(final_series.alias(symbol))

        # Combine the datetime column with the list of calculated series
        datetime_col_df = df_base.select(pl.col(DEFAULT_DATETIME_COL))
        result_df = datetime_col_df.with_columns(output_series_list)
        return result_df

