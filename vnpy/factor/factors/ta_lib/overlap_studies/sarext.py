# Auto-generated by factor_generator.py using polars-talib
import polars as pl
import polars_talib as plta
from typing import Dict, List

from vnpy.factor.template import FactorTemplate
from vnpy.factor.memory import FactorMemory

DEFAULT_DATETIME_COL = "datetime"


class SAREXT(FactorTemplate):
    """
    Calculates the SAREXT indicator.
    """

    author = "Auto-Generated by FactorGenerator"
    factor_name = "SAREXT"

    def __init__(self, setting: dict | None = None, **kwargs):
        """
        Initializes the SAREXT.
        Required parameters: startvalue, offsetonreverse, accelerationinitlong, accelerationlong, accelerationmaxlong, accelerationinitshort, accelerationshort, accelerationmaxshort
        """
        super().__init__(setting, **kwargs)

        # --- Parameter Validation and Assignment ---
        if not hasattr(self.params, "startvalue"): raise ValueError(f"{self.factor_key} requires a 'startvalue' parameter.")
        try: self.startvalue = int(self.params.startvalue)
        except (ValueError, TypeError): self.startvalue = float(self.params.startvalue)
        if not hasattr(self.params, "offsetonreverse"): raise ValueError(f"{self.factor_key} requires a 'offsetonreverse' parameter.")
        try: self.offsetonreverse = int(self.params.offsetonreverse)
        except (ValueError, TypeError): self.offsetonreverse = float(self.params.offsetonreverse)
        if not hasattr(self.params, "accelerationinitlong"): raise ValueError(f"{self.factor_key} requires a 'accelerationinitlong' parameter.")
        try: self.accelerationinitlong = int(self.params.accelerationinitlong)
        except (ValueError, TypeError): self.accelerationinitlong = float(self.params.accelerationinitlong)
        if not hasattr(self.params, "accelerationlong"): raise ValueError(f"{self.factor_key} requires a 'accelerationlong' parameter.")
        try: self.accelerationlong = int(self.params.accelerationlong)
        except (ValueError, TypeError): self.accelerationlong = float(self.params.accelerationlong)
        if not hasattr(self.params, "accelerationmaxlong"): raise ValueError(f"{self.factor_key} requires a 'accelerationmaxlong' parameter.")
        try: self.accelerationmaxlong = int(self.params.accelerationmaxlong)
        except (ValueError, TypeError): self.accelerationmaxlong = float(self.params.accelerationmaxlong)
        if not hasattr(self.params, "accelerationinitshort"): raise ValueError(f"{self.factor_key} requires a 'accelerationinitshort' parameter.")
        try: self.accelerationinitshort = int(self.params.accelerationinitshort)
        except (ValueError, TypeError): self.accelerationinitshort = float(self.params.accelerationinitshort)
        if not hasattr(self.params, "accelerationshort"): raise ValueError(f"{self.factor_key} requires a 'accelerationshort' parameter.")
        try: self.accelerationshort = int(self.params.accelerationshort)
        except (ValueError, TypeError): self.accelerationshort = float(self.params.accelerationshort)
        if not hasattr(self.params, "accelerationmaxshort"): raise ValueError(f"{self.factor_key} requires a 'accelerationmaxshort' parameter.")
        try: self.accelerationmaxshort = int(self.params.accelerationmaxshort)
        except (ValueError, TypeError): self.accelerationmaxshort = float(self.params.accelerationmaxshort)

    def calculate(self, input_data: dict[str, pl.DataFrame], memory: FactorMemory) -> pl.DataFrame:
        """Calculates the indicator using a temporary DataFrame and expression API for each symbol."""
        # --- Input Data Validation ---
        if input_data["high"].is_empty(): return pl.DataFrame(data={}, schema=self.get_output_schema())
        if input_data["low"].is_empty(): return pl.DataFrame(data={}, schema=self.get_output_schema())

        # --- Eager Calculation Loop ---
        df_base = input_data.get("close")
        symbol_columns = [col for col in df_base.columns if col != DEFAULT_DATETIME_COL]
        if self.vt_symbols:
            symbol_columns = [col for col in symbol_columns if col in self.vt_symbols]

        if not symbol_columns:
            return pl.DataFrame(data={}, schema=self.get_output_schema())

        kwargs = { "startvalue": self.startvalue, "offsetonreverse": self.offsetonreverse, "accelerationinitlong": self.accelerationinitlong, "accelerationlong": self.accelerationlong, "accelerationmaxlong": self.accelerationmaxlong, "accelerationinitshort": self.accelerationinitshort, "accelerationshort": self.accelerationshort, "accelerationmaxshort": self.accelerationmaxshort }
        output_series_list = []

        for symbol in symbol_columns:
            # 1. Create a temporary DataFrame with this symbol's required inputs
            temp_df_inputs = { "high": input_data["high"][symbol], "low": input_data["low"][symbol] }
            input_df = pl.DataFrame(temp_df_inputs)

            # 2. Define the calculation expression using pl.col()
            calc_expression = plta.sarext(high=pl.col("high"), low=pl.col("low"), **kwargs).alias("result")

            # 3. Execute the expression on the temporary DataFrame
            result_df_with_indicator = input_df.with_columns(calc_expression)

            result_series_or_struct = result_df_with_indicator.get_column("result")

            # 4. Handle multi-output indicators if necessary using index access
            if False:
                final_series = result_series_or_struct.struct[None]
            else:
                final_series = result_series_or_struct

            output_series_list.append(final_series.alias(symbol))

        # Combine the datetime column with the list of calculated series
        datetime_col_df = df_base.select(pl.col(DEFAULT_DATETIME_COL))
        result_df = datetime_col_df.with_columns(output_series_list)
        return result_df

