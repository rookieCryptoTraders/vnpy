# Auto-generated by factor_generator using polats ta-lib.py
import polars as pl
import polars_talib as plta

from vnpy.factor.template import FactorTemplate
from vnpy.factor.memory import FactorMemory

DEFAULT_DATETIME_COL = "datetime"


class STOCH_SLOWDFactor(FactorTemplate):
    """
    Calculates the STOCH_SLOWD indicator.
    """

    author = "Auto-Generated by FactorGenerator"
    factor_name = "STOCH_SLOWD"

    def __init__(self, setting: dict | None = None, vt_symbols: list[str] | None = None, **kwargs):
        """
        Initializes the STOCH_SLOWDFactor.
        Required parameters: fastk_period, slowk_period, slowk_matype, slowd_period, slowd_matype
        """
        super().__init__(setting, **kwargs)
        self.vt_symbols: list[str] = vt_symbols if vt_symbols else []

        # --- Parameter Validation and Assignment ---
        if not hasattr(self.params, "fastk_period"): raise ValueError(f"{self.factor_key} requires a 'fastk_period' parameter.")
        try: self.fastk_period = float(self.params.fastk_period)
        except (ValueError, TypeError): self.fastk_period = int(self.params.fastk_period)
        if not hasattr(self.params, "slowk_period"): raise ValueError(f"{self.factor_key} requires a 'slowk_period' parameter.")
        try: self.slowk_period = float(self.params.slowk_period)
        except (ValueError, TypeError): self.slowk_period = int(self.params.slowk_period)
        if not hasattr(self.params, "slowk_matype"): raise ValueError(f"{self.factor_key} requires a 'slowk_matype' parameter.")
        try: self.slowk_matype = float(self.params.slowk_matype)
        except (ValueError, TypeError): self.slowk_matype = int(self.params.slowk_matype)
        if not hasattr(self.params, "slowd_period"): raise ValueError(f"{self.factor_key} requires a 'slowd_period' parameter.")
        try: self.slowd_period = float(self.params.slowd_period)
        except (ValueError, TypeError): self.slowd_period = int(self.params.slowd_period)
        if not hasattr(self.params, "slowd_matype"): raise ValueError(f"{self.factor_key} requires a 'slowd_matype' parameter.")
        try: self.slowd_matype = float(self.params.slowd_matype)
        except (ValueError, TypeError): self.slowd_matype = int(self.params.slowd_matype)


    def calculate(self, input_data: dict[str, pl.DataFrame], memory: FactorMemory) -> pl.DataFrame:
        """Calculates the indicator and extracts the relevant component if necessary."""
        # --- Input Data Validation ---
        if input_data.get("high") is None or input_data["high"].is_empty(): return pl.DataFrame(data={}, schema=self.get_output_schema())
        if input_data.get("close") is None or input_data["close"].is_empty(): return pl.DataFrame(data={}, schema=self.get_output_schema())
        if input_data.get("low") is None or input_data["low"].is_empty(): return pl.DataFrame(data={}, schema=self.get_output_schema())

        # --- Core Calculation ---
        df_base = input_data.get("close") or next(iter(input_data.values()))

        symbol_columns = [col for col in df_base.columns if col != DEFAULT_DATETIME_COL]
        if self.vt_symbols:
            symbol_columns = [col for col in symbol_columns if col in self.vt_symbols]

        if not symbol_columns:
            return pl.DataFrame(data={}, schema=self.get_output_schema())

        kwargs = { "fastk_period": self.fastk_period, "slowk_period": self.slowk_period, "slowk_matype": self.slowk_matype, "slowd_period": self.slowd_period, "slowd_matype": self.slowd_matype }
        expressions_to_run = []

        for symbol in symbol_columns:
            symbol_inputs = { "high": pl.col(symbol), "low": pl.col(symbol), "close": pl.col(symbol) }

            result_expr = plta.stoch(**symbol_inputs, **kwargs)

            # If this is a component of a multi-output function, extract the field.
            if "slowd":
                result_expr = result_expr.struct.field("slowd")

            expressions_to_run.append(result_expr.alias(symbol))

        # Join all necessary input dataframes for the calculation
        df_exec_base = df_base
        for col_name, df_wide in input_data.items():
            if col_name != "close" and col_name in {'high', 'close', 'low'}:
                if df_wide is not df_base:
                    df_exec_base = df_exec_base.join(df_wide.select(pl.all().exclude(DEFAULT_DATETIME_COL)), on=DEFAULT_DATETIME_COL, how="left")

        # Execute all expressions at once
        result_df = df_exec_base.select(pl.col(DEFAULT_DATETIME_COL), *expressions_to_run)
        return result_df

