# -*- coding: utf-8 -*-
"""
Defines the BaseStrategyEngine, the core component for managing and executing
trading strategies within the vn.py framework. It integrates portfolio
management capabilities via an optional PortfolioEngine.

Core Responsibilities:
- Loading strategy code modules and configuration settings.
- Managing the lifecycle of strategy instances (initialization, start, stop).
- Subscribing to necessary market data for strategies.
- Processing market events (e.g., factor updates) and triggering strategy logic.
- Handling order requests generated by strategies via a dedicated ExecutionAgent.
- Routing order and trade update events back to the relevant strategy instances.
- Providing utility functions for strategies to access market data, contract details,
  and portfolio state (if PortfolioEngine is active).
- Persisting strategy settings and optional runtime state.
"""

import importlib
import traceback
import os
import sys
import glob
from typing import Type, Callable, Dict, List, Optional, Any, Tuple, Set, Union
from datetime import datetime, timezone, date
from concurrent.futures import ThreadPoolExecutor
from logging import INFO, ERROR, DEBUG, WARNING # Standard logging levels
from pathlib import Path
from types import ModuleType

# --- VnTrader Core Imports ---
from vnpy.event import Event, EventEngine
from vnpy.strategy.base import EVENT_PORTFOLIO_STRATEGY
from vnpy.trader.engine import BaseEngine, MainEngine
from vnpy.trader.object import (
    OrderRequest, SubscribeRequest, CancelRequest,
    LogData, TickData, OrderData, TradeData, BarData, ContractData
)
from vnpy.trader.event import (
    EVENT_ORDER, EVENT_TRADE, EVENT_CONTRACT, EVENT_TIMER, EVENT_LOG,
    EVENT_FACTOR
)
from vnpy.trader.constant import EngineType
from vnpy.trader.utility import load_json, save_json, get_file_path, virtual
from vnpy.trader.database import BaseDatabase, get_database
from vnpy.trader.datafeed import BaseDatafeed, get_datafeed

# --- Strategy & Portfolio Specific Imports ---
    # Assumes portfolio_manager is accessible (e.g., sibling directory or installed)
from vnpy.app.portfolio_manager.engine import PortfolioEngine
PORTFOLIO_APP_NAME = PortfolioEngine.APP_NAME

from vnpy.strategy.execution_agent import ExecutionAgent

from vnpy.strategy.template import StrategyTemplate

# --- Constants ---
STRATEGY_ENGINE_APP_NAME: str = "StrategyEngine"   # Default unique name for this engine
DEFAULT_STRATEGIES_DIR: str = "strategies"         # Default subdirectory for strategy code
DEFAULT_EXECUTION_GATEWAY: str = "BINANCE"         # Default gateway for order execution

# Filename Templates
SETTING_FILENAME_TPL: str = "{}_setting.json"       # Template for engine settings filename
STRATEGY_DATA_FILENAME_TPL: str = "strategy_data_{}.json" # Template for strategy runtime data

# Event Types
EVENT_STRATEGY_LOG = EVENT_LOG                     # Use standard log event type
EVENT_STRATEGY_UPDATE = EVENT_PORTFOLIO_STRATEGY   # Use standard strategy update event type


class BaseStrategyEngine(BaseEngine):
    """
    Core engine for loading, managing the lifecycle, and executing trading
    strategies derived from `StrategyTemplate`. Integrates with an optional
    `PortfolioEngine` for PnL and position tracking.
    """

    # Engine type can be overridden by MainEngine in backtesting mode
    engine_type: EngineType = EngineType.LIVE

    def __init__(
        self,
        main_engine: MainEngine,
        event_engine: EventEngine,
        engine_name: str = STRATEGY_ENGINE_APP_NAME
    ) -> None:
        """
        Initialize the BaseStrategyEngine.

        Args:
            main_engine: The main trading engine instance.
            event_engine: The central event engine instance.
            engine_name: A unique name for this engine instance.
        """
        super().__init__(main_engine, event_engine, engine_name=engine_name)

        # --- Load Configuration from MainEngine Settings ---
        engine_settings = main_engine.get_settings(f"{engine_name}.") # Prefix for engine-specific settings
        strategies_dir = engine_settings.get("strategies_dir", DEFAULT_STRATEGIES_DIR)
        self.execution_gateway_name = engine_settings.get("execution_gateway", DEFAULT_EXECUTION_GATEWAY)

        self.strategies_path: Path = Path.cwd().joinpath(strategies_dir)
        self.setting_filename: str = SETTING_FILENAME_TPL.format(self.engine_name)

        self.write_log(f"Engine Name: {self.engine_name}", level=DEBUG)
        self.write_log(f"Strategies Directory: {self.strategies_path}", level=INFO)
        self.write_log(f"Execution Gateway: {self.execution_gateway_name}", level=INFO)
        self.write_log(f"Settings File: {self.setting_filename}", level=DEBUG)

        # --- Core Strategy State ---
        self.strategy_classes: Dict[str, Type[StrategyTemplate]] = {} # {ClassName: Class}
        self.strategies: Dict[str, StrategyTemplate] = {}           # {StrategyName: Instance}
        self.strategy_settings: Dict[str, dict] = {}                # {StrategyName: SettingDict} Loaded from file

        # --- Supporting Components ---
        self.database: BaseDatabase = get_database()
        self.datafeed: BaseDatafeed = get_datafeed()
        self.execution_agent: ExecutionAgent = self._init_execution_agent()
        self.portfolio_engine: Optional[PortfolioEngine] = self._init_portfolio_engine()

        # --- Asynchronous Operations ---
        self.init_executor: ThreadPoolExecutor = ThreadPoolExecutor(
            max_workers=1, thread_name_prefix=f"{self.engine_name}_Init"
        )

        # --- Factor Handling ---
        self.latest_factors: Dict[str, Any] = {}
        self.factor_update_time: Optional[datetime] = None

        self.write_log("Engine initialization started.", level=DEBUG)

    def _init_execution_agent(self) -> ExecutionAgent:
        """Initialize the ExecutionAgent."""
        self.write_log(f"Initializing ExecutionAgent for gateway: {self.execution_gateway_name}", level=INFO)
        try:
            if not callable(ExecutionAgent) or ExecutionAgent.__name__ == 'object': # Check if it's the dummy
                raise ImportError("ExecutionAgent class is not valid or not imported.")
            agent = ExecutionAgent(
                main_engine=self.main_engine,
                gateway_name=self.execution_gateway_name
            )
            self.write_log("ExecutionAgent initialized successfully.", level=INFO)
            return agent
        except Exception as e:
            self.write_log(f"FATAL: Failed to initialize ExecutionAgent: {e}\n{traceback.format_exc()}", level=ERROR)
            print(f"FATAL ERROR in {self.engine_name}: ExecutionAgent failed. Order functionality disabled.")
            class DummyExecutionAgent:
                def send_order(self, req: OrderRequest, lock: bool, net: bool) -> List[str]: self.log_error(req); return []
                def cancel_order(self, req: Union[CancelRequest, OrderData]) -> None: self.log_error(req)
                def log_error(self, req): print(f"ERROR: ExecutionAgent not initialized. Cannot process request: {req}")
            return DummyExecutionAgent()

    def _init_portfolio_engine(self) -> Optional[PortfolioEngine]:
        """Initialize the PortfolioEngine if available."""
        if PortfolioEngine: # Check if class was imported successfully
            self.write_log(f"Initializing PortfolioEngine ('{PORTFOLIO_APP_NAME}')...", level=INFO)
            try:
                portfolio_engine = PortfolioEngine(self.main_engine, self.event_engine)
                self.write_log(f"PortfolioEngine ('{PORTFOLIO_APP_NAME}') initialized successfully.", level=INFO)
                return portfolio_engine
            except Exception as e:
                self.write_log(f"Failed to initialize PortfolioEngine: {e}\n{traceback.format_exc()}", level=ERROR)
                return None
        else:
            self.write_log("PortfolioEngine class not available. Portfolio management disabled.", level=WARNING)
            return None

    # --------------------------------
    # Engine Lifecycle
    # --------------------------------

    def init_engine(self) -> None:
        """Initialize the engine: Load components, strategies, settings, data, and register events."""
        self.write_log("Initializing Strategy Engine components...")
        try:
            self.init_datafeed()
            self.load_all_strategy_classes()
            self.load_all_strategy_settings()
            self.create_strategies_from_settings()
            self.load_all_strategy_data()
            self.register_event()
            self.write_log(f"{self.engine_name} initialization complete. "
                           f"{len(self.strategies)} strategies loaded. "
                           f"Portfolio Management: {'ENABLED' if self.portfolio_engine else 'DISABLED'}", level=INFO)
        except Exception as e:
            self.write_log(f"CRITICAL ERROR during engine initialization: {e}\n{traceback.format_exc()}", level=ERROR)

    def init_datafeed(self) -> None:
        """Initialize the data feed connection."""
        self.write_log("Initializing datafeed...", level=INFO)
        try:
            logger_callback = lambda msg: self.write_log(f"[DataFeed] {msg}", level=DEBUG)
            result: bool = self.datafeed.init(logger_callback)
            if result:
                self.write_log("Datafeed initialized successfully.", level=INFO)
            else:
                 self.write_log("Datafeed initialization failed (returned False). Check datafeed logs.", level=WARNING)
        except Exception as e:
             self.write_log(f"Exception during datafeed initialization: {e}", level=ERROR)

    def register_event(self) -> None:
        """Register event listeners required by the StrategyEngine."""
        self.write_log("Registering engine event listeners...", level=DEBUG)
        try:
            self.event_engine.register(EVENT_ORDER, self.process_order_event)
            self.event_engine.register(EVENT_TRADE, self.process_trade_event)
            self.event_engine.register(EVENT_FACTOR, self.process_factor_event)
            self.write_log("Engine event listeners registered.", level=DEBUG)
        except Exception as e:
            self.write_log(f"Error registering engine events: {e}", level=ERROR)

    def close(self) -> None:
        """Cleanly shut down the engine and its components."""
        self.write_log(f"Shutting down {self.engine_name}...")
        self.stop_all_strategies()
        if self.portfolio_engine:
            try:
                self.portfolio_engine.close()
                self.write_log(f"PortfolioEngine ('{PORTFOLIO_APP_NAME}') closed.", level=INFO)
            except Exception as e:
                self.write_log(f"Error closing PortfolioEngine: {e}\n{traceback.format_exc()}", level=ERROR)
        self.unregister_event()
        self.write_log("Shutting down init executor...", level=DEBUG)
        self.init_executor.shutdown(wait=True)
        self.write_log("Init executor shut down.", level=DEBUG)
        self.write_log(f"{self.engine_name} shut down complete.", level=INFO)

    def unregister_event(self) -> None:
        """Unregister event listeners used by the StrategyEngine."""
        self.write_log("Unregistering engine event listeners...", level=DEBUG)
        try:
            self.event_engine.unregister(EVENT_ORDER, self.process_order_event)
            self.event_engine.unregister(EVENT_TRADE, self.process_trade_event)
            self.event_engine.unregister(EVENT_FACTOR, self.process_factor_event)
            self.write_log("Engine event listeners unregistered.", level=DEBUG)
        except Exception as e:
            self.write_log(f"Error unregistering engine events: {e}", level=ERROR)

    # --------------------------------
    # Strategy Loading and Settings
    # --------------------------------

    def load_all_strategy_classes(self) -> None:
        """Scan the strategies directory and load all found strategy classes."""
        self.write_log(f"Loading strategy classes from directory: {self.strategies_path}", level=INFO)
        if not self.strategies_path.is_dir():
            self.write_log(f"Strategies directory not found or is not a directory: {self.strategies_path}", level=ERROR)
            return

        initial_class_count = len(self.strategy_classes)
        module_prefix = self.strategies_path.name

        for suffix in ["py", "pyd", "so"]:
            pathname = str(self.strategies_path.joinpath(f"*.{suffix}"))
            for filepath in glob.glob(pathname):
                module_path = Path(filepath)
                stem = module_path.stem
                if stem.startswith("_"): continue

                strategy_module_name = f"{module_prefix}.{stem}"
                try:
                    self._load_strategy_class_from_module(strategy_module_name)
                except ImportError:
                     self.write_log(f"Relative import failed for {strategy_module_name}, trying direct import of '{stem}'...", level=DEBUG)
                     try:
                          self._load_strategy_class_from_module(stem)
                     except ImportError as e:
                          self.write_log(f"Direct import also failed for '{stem}': {e}", level=ERROR)

        loaded_count = len(self.strategy_classes) - initial_class_count
        self.write_log(f"Finished loading strategy classes. Found {loaded_count} new classes. Total: {len(self.strategy_classes)}", level=INFO)

    def _load_strategy_class_from_module(self, module_name: str) -> int:
        """Load strategy classes from a specific module file, handling reload."""
        count = 0
        try:
            module_to_load: ModuleType
            if module_name in sys.modules:
                 module_to_load = importlib.reload(sys.modules[module_name])
                 self.write_log(f"Reloaded strategy module: {module_name}", level=DEBUG)
            else:
                 module_to_load = importlib.import_module(module_name)
                 self.write_log(f"Imported strategy module: {module_name}", level=DEBUG)

            for name in dir(module_to_load):
                value = getattr(module_to_load, name)
                if (isinstance(value, type) and issubclass(value, StrategyTemplate) and value is not StrategyTemplate):
                    class_name = value.__name__
                    if class_name in self.strategy_classes and self.strategy_classes[class_name] is not value:
                        self.write_log(f"Warning: Strategy class '{class_name}' from '{module_name}' conflicts with existing class. Skipping.", level=WARNING)
                        continue
                    if class_name not in self.strategy_classes:
                        self.strategy_classes[class_name] = value
                        count += 1
                        self.write_log(f"Loaded strategy class: '{class_name}' from '{module_name}'", level=DEBUG)
            return count
        except ModuleNotFoundError:
            self.write_log(f"Module '{module_name}' not found.", level=DEBUG)
            raise
        except Exception:
            self.write_log(f"Failed to load strategy class from module '{module_name}':\n{traceback.format_exc()}", level=ERROR)
            return 0

    def load_all_strategy_settings(self) -> None:
        """Load strategy settings from the JSON configuration file."""
        self.write_log(f"Loading strategy settings from: {self.setting_filename}", level=INFO)
        filepath = get_file_path(self.setting_filename)
        loaded_settings = load_json(filepath)

        if not isinstance(loaded_settings, dict):
            self.write_log(f"Invalid settings file format in '{filepath}': Expected a dictionary, got {type(loaded_settings)}. Ignoring.", level=ERROR)
            self.strategy_settings = {}
        else:
            self.strategy_settings = loaded_settings
            self.write_log(f"Loaded settings for {len(self.strategy_settings)} strategies.", level=INFO)

    def create_strategies_from_settings(self) -> None:
        """Instantiate strategy objects based on the loaded settings."""
        self.write_log("Creating strategy instances from settings...", level=INFO)
        created_count = 0
        invalid_settings_names = []

        for strategy_name, setting in self.strategy_settings.items():
            if not self._validate_setting_entry(strategy_name, setting):
                invalid_settings_names.append(strategy_name)
                continue
            class_name = setting["class_name"]
            vt_symbols = setting["vt_symbols"]
            strategy_params = setting["setting"]

            if self.add_strategy(class_name, strategy_name, vt_symbols, strategy_params):
                created_count += 1
            else:
                invalid_settings_names.append(strategy_name)

        if invalid_settings_names:
            for name in invalid_settings_names:
                self.strategy_settings.pop(name, None)
            self.write_log(f"Removed {len(invalid_settings_names)} invalid or failed strategy settings from runtime config.", level=WARNING)

        self.write_log(f"Finished creating strategy instances. Successful: {created_count}", level=INFO)

    def _validate_setting_entry(self, strategy_name: str, setting: Any) -> bool:
        """Perform basic validation on a single strategy setting entry."""
        if not isinstance(setting, dict):
            self.write_log(f"Invalid setting for '{strategy_name}': Entry must be a dictionary.", level=WARNING)
            return False
        required_keys = {"class_name", "vt_symbols", "setting"}
        if not required_keys.issubset(setting.keys()):
            self.write_log(f"Invalid setting for '{strategy_name}': Missing required keys: {required_keys - set(setting.keys())}.", level=WARNING)
            return False
        class_name = setting["class_name"]
        if not isinstance(class_name, str) or not class_name:
            self.write_log(f"Invalid setting for '{strategy_name}': 'class_name' must be a non-empty string.", level=WARNING)
            return False
        if not isinstance(setting["vt_symbols"], list):
            self.write_log(f"Invalid setting for '{strategy_name}': 'vt_symbols' must be a list.", level=WARNING)
            return False
        if not isinstance(setting["setting"], dict):
            self.write_log(f"Invalid setting for '{strategy_name}': 'setting' (parameters) must be a dictionary.", level=WARNING)
            return False
        if class_name not in self.strategy_classes:
             self.write_log(f"Invalid setting for '{strategy_name}': Strategy class '{class_name}' is not loaded.", level=WARNING)
             return False
        return True

    def save_all_strategy_settings(self) -> None:
        """Save the current configuration of all active strategies to the settings file."""
        self.write_log(f"Saving strategy settings to: {self.setting_filename}", level=DEBUG)
        settings_to_save: Dict[str, dict] = {}
        for strategy_name, strategy in self.strategies.items():
            try:
                settings_to_save[strategy_name] = self._get_strategy_setting_dict(strategy)
            except Exception as e:
                 self.write_log(f"Error preparing settings for strategy '{strategy_name}' for saving: {e}", level=ERROR, strategy=strategy)

        filepath = get_file_path(self.setting_filename)
        if save_json(filepath, settings_to_save):
            self.write_log(f"Saved settings for {len(settings_to_save)} strategies to {filepath}", level=INFO)
        else:
            self.write_log(f"Failed to save strategy settings to {filepath} (save_json returned False)", level=ERROR)

    def _get_strategy_setting_dict(self, strategy: StrategyTemplate) -> dict:
        """Create the dictionary representation of a strategy's settings for saving."""
        if not hasattr(strategy, 'get_parameters') or not callable(strategy.get_parameters):
             raise AttributeError(f"Strategy '{strategy.strategy_name}' missing 'get_parameters' method.")
        strategy_params = strategy.get_parameters()
        strategy_params['vt_symbols'] = strategy.vt_symbols
        strategy_params['class_name'] = strategy.__class__.__name__
        setting_dict = {
            "class_name": strategy_params.pop('class_name'),
            "vt_symbols": strategy_params.pop('vt_symbols'),
            "setting": strategy_params
        }
        return setting_dict

    def update_strategy_setting_cache(self, strategy_name: str) -> None:
        """Update the internal settings cache (self.strategy_settings) for a single strategy."""
        if strategy_name not in self.strategies:
            self.write_log(f"Cannot update settings cache: Strategy '{strategy_name}' not found.", level=ERROR)
            return
        strategy = self.strategies[strategy_name]
        try:
             self.strategy_settings[strategy_name] = self._get_strategy_setting_dict(strategy)
             self.write_log(f"Updated internal settings cache for strategy: {strategy_name}", level=DEBUG)
        except Exception as e:
             self.write_log(f"Error updating settings cache for strategy '{strategy_name}': {e}", level=ERROR, strategy=strategy)

    def remove_strategy_setting_cache(self, strategy_name: str) -> None:
        """Remove a strategy's setting from the internal cache. Does NOT save to file."""
        if strategy_name in self.strategy_settings:
            if self.strategy_settings.pop(strategy_name, None):
                self.write_log(f"Removed setting for strategy '{strategy_name}' from internal cache.", level=DEBUG)

    # --------------------------------
    # Strategy Runtime Data Management
    # --------------------------------
    @virtual
    def load_all_strategy_data(self) -> None:
        """Load runtime data for all strategy instances that implement `load_data`."""
        self.write_log("Loading strategy runtime data...", level=INFO)
        loaded_count = 0
        for strategy_name in list(self.strategies.keys()):
             if strategy_name in self.strategies:
                 strategy = self.strategies[strategy_name]
                 if self._load_single_strategy_data(strategy):
                     loaded_count += 1
        self.write_log(f"Finished loading runtime data. Loaded for {loaded_count} strategies.", level=INFO)

    def _load_single_strategy_data(self, strategy: StrategyTemplate) -> bool:
        """Load runtime data for a single strategy instance if supported."""
        if not (hasattr(strategy, 'load_data') and callable(strategy.load_data)):
            return False
        strategy_name = strategy.strategy_name
        data_filename = STRATEGY_DATA_FILENAME_TPL.format(strategy_name)
        filepath = get_file_path(data_filename)
        if not filepath.exists():
            self.write_log(f"No runtime data file found for strategy: {strategy_name} at {filepath}", level=DEBUG, strategy=strategy)
            return False
        try:
            strategy_data = load_json(filepath)
            if strategy_data:
                self.write_log(f"Attempting to load runtime data into strategy: {strategy_name}", level=DEBUG, strategy=strategy)
                strategy.load_data(strategy_data)
                self.write_log(f"Successfully loaded runtime data for strategy: {strategy_name}", level=INFO, strategy=strategy)
                return True
            else:
                self.write_log(f"Runtime data file for strategy {strategy_name} is empty or invalid JSON at {filepath}", level=WARNING, strategy=strategy)
                return False
        except Exception:
            self.write_log(f"Error occurred within {strategy_name}.load_data() method:\n{traceback.format_exc()}", level=ERROR, strategy=strategy)
            return False

    @virtual
    def save_strategy_data(self, strategy_name: str) -> bool:
        """Save runtime data for a specific strategy instance if supported."""
        if strategy_name not in self.strategies:
            self.write_log(f"Cannot save data: Strategy '{strategy_name}' not found.", level=ERROR)
            return False
        strategy = self.strategies[strategy_name]
        if not (hasattr(strategy, 'get_data') and callable(strategy.get_data)):
            self.write_log(f"Strategy '{strategy_name}' does not implement get_data(). Cannot save runtime data.", level=DEBUG, strategy=strategy)
            return False
        data_filename = STRATEGY_DATA_FILENAME_TPL.format(strategy_name)
        filepath = get_file_path(data_filename)
        try:
            strategy_data = strategy.get_data()
            if not isinstance(strategy_data, dict):
                 self.write_log(f"Strategy '{strategy_name}' get_data() did not return a dictionary (returned {type(strategy_data)}). Cannot save.", level=WARNING, strategy=strategy)
                 return False
            self.write_log(f"Saving runtime data for strategy: {strategy_name} to {filepath}", level=DEBUG, strategy=strategy)
            if save_json(filepath, strategy_data):
                return True
            else:
                self.write_log(f"Failed to save runtime data for strategy {strategy_name} (save_json returned False)", level=ERROR, strategy=strategy)
                return False
        except Exception:
            self.write_log(f"Error occurred within {strategy_name}.get_data() method:\n{traceback.format_exc()}", level=ERROR, strategy=strategy)
            return False

    def save_all_strategy_data(self) -> None:
        """Save runtime data for all active strategies that support it."""
        self.write_log("Saving runtime data for all strategies...", level=DEBUG)
        saved_count = 0
        for strategy_name in list(self.strategies.keys()):
            if strategy_name in self.strategies:
                if self.save_strategy_data(strategy_name):
                    saved_count += 1
        self.write_log(f"Finished saving runtime data. Saved for {saved_count} strategies.", level=INFO)

    # --------------------------------
    # Strategy Instance Management (Add, Edit, Remove)
    # --------------------------------
    def add_strategy(self, class_name: str, strategy_name: str, vt_symbols: List[str], setting: dict) -> bool:
        """Create, validate, and add a new strategy instance."""
        if not isinstance(strategy_name, str) or not strategy_name:
             self.write_log("Add failed: Strategy name must be a non-empty string.", level=ERROR)
             return False
        if strategy_name in self.strategies:
            self.write_log(f"Add failed: Strategy name '{strategy_name}' already exists.", level=ERROR)
            return False
        strategy_class = self.strategy_classes.get(class_name)
        if not strategy_class:
            self.write_log(f"Add failed for '{strategy_name}': Strategy class '{class_name}' not found.", level=ERROR)
            return False
        if not isinstance(vt_symbols, list):
            self.write_log(f"Add failed for '{strategy_name}': vt_symbols must be a list.", level=ERROR)
            return False
        if not isinstance(setting, dict):
            self.write_log(f"Add failed for '{strategy_name}': setting (parameters) must be a dictionary.", level=ERROR)
            return False
        try:
            self.write_log(f"Instantiating strategy '{strategy_name}' from class '{class_name}'...", level=DEBUG)
            strategy = strategy_class(self, strategy_name, vt_symbols, setting)
            if not hasattr(strategy, 'get_parameters') or not callable(strategy.get_parameters):
                 raise TypeError("Instantiated strategy object missing required 'get_parameters' method.")
        except Exception:
            self.write_log(f"Failed to instantiate or validate strategy '{strategy_name}' from class '{class_name}':\n{traceback.format_exc()}", level=ERROR)
            return False
        self.strategies[strategy_name] = strategy
        self.update_strategy_setting_cache(strategy_name)
        self.write_log(f"Strategy '{strategy_name}' (Class: '{class_name}') added successfully.", level=INFO, strategy=strategy)
        self.put_strategy_update_event(strategy)
        return True

    def edit_strategy(self, strategy_name: str, setting: dict) -> bool:
        """Update parameters of an existing, stopped strategy instance. Saves settings."""
        if strategy_name not in self.strategies:
            self.write_log(f"Edit failed: Strategy '{strategy_name}' not found.", level=ERROR)
            return False
        strategy = self.strategies[strategy_name]
        if strategy.trading:
            self.write_log(f"Edit failed: Strategy '{strategy_name}' is currently running. Stop it before editing.", level=WARNING, strategy=strategy)
            return False
        if not isinstance(setting, dict):
            self.write_log(f"Edit failed for '{strategy_name}': New setting must be a dictionary.", level=ERROR)
            return False
        if not (hasattr(strategy, 'update_setting') and callable(strategy.update_setting)):
            self.write_log(f"Edit failed: Strategy class '{strategy.__class__.__name__}' does not implement 'update_setting'.", level=ERROR, strategy=strategy)
            return False
        try:
            self.write_log(f"Applying parameter updates to strategy '{strategy_name}'...", level=DEBUG, strategy=strategy)
            strategy.update_setting(setting)
            self.update_strategy_setting_cache(strategy_name)
            self.save_all_strategy_settings()
            self.write_log(f"Strategy '{strategy_name}' parameters updated and settings saved. Re-initialize the strategy to use new parameters.", level=INFO, strategy=strategy)
            self.put_strategy_update_event(strategy)
            return True
        except Exception:
            self.write_log(f"Error applying settings update to strategy '{strategy_name}':\n{traceback.format_exc()}", level=ERROR, strategy=strategy)
            return False

    def remove_strategy(self, strategy_name: str, remove_data_file: bool = False) -> bool:
        """Remove a stopped strategy instance. Saves settings. Optionally removes data."""
        if strategy_name not in self.strategies:
            self.write_log(f"Remove failed: Strategy '{strategy_name}' not found.", level=WARNING)
            return False
        strategy = self.strategies[strategy_name]
        if strategy.trading:
            self.write_log(f"Remove failed: Strategy '{strategy_name}' is currently running. Stop it first.", level=ERROR, strategy=strategy)
            return False
        self.write_log(f"Removing strategy '{strategy_name}'...", level=INFO, strategy=strategy)
        if hasattr(strategy, 'on_stop') and callable(strategy.on_stop):
            self.write_log(f"Ensuring on_stop is called for '{strategy_name}' during removal.", level=DEBUG, strategy=strategy)
            self.call_strategy_func(strategy, strategy.on_stop)
        removed_strategy = self.strategies.pop(strategy_name, None)
        if removed_strategy:
            self.remove_strategy_setting_cache(strategy_name)
            self.save_all_strategy_settings()
            if remove_data_file:
                data_filename = STRATEGY_DATA_FILENAME_TPL.format(strategy_name)
                filepath = get_file_path(data_filename)
                try:
                    if filepath.exists():
                        os.remove(filepath)
                        self.write_log(f"Removed runtime data file: {filepath}", level=INFO)
                except OSError as e:
                    self.write_log(f"Error removing runtime data file {filepath}: {e}", level=WARNING)
            self.put_strategy_update_event(removed_strategy, removed=True)
            self.write_log(f"Strategy '{strategy_name}' removed successfully.", level=INFO)
            return True
        else:
            self.write_log(f"Internal error during removal of strategy '{strategy_name}'.", level=ERROR)
            return False

    # --------------------------------
    # Strategy Lifecycle Control (Init, Start, Stop)
    # --------------------------------
    def init_strategy(self, strategy_name: str) -> None:
        """Asynchronously initialize a strategy instance."""
        if strategy_name not in self.strategies:
            self.write_log(f"Init request ignored: Strategy '{strategy_name}' not found.", level=ERROR)
            return
        strategy = self.strategies[strategy_name]
        if strategy.inited:
            self.write_log(f"Init request ignored: Strategy '{strategy_name}' is already initialized.", level=DEBUG, strategy=strategy)
            return
        self.write_log(f"Queueing initialization for strategy: {strategy_name}", level=INFO, strategy=strategy)
        self.init_executor.submit(self._init_strategy_thread, strategy_name)

    def _init_strategy_thread(self, strategy_name: str) -> None:
        """[Internal] Worker thread function for initializing a single strategy."""
        if strategy_name not in self.strategies:
            self.write_log(f"Init aborted: Strategy '{strategy_name}' removed before initialization started.", level=WARNING)
            return
        strategy = self.strategies[strategy_name]
        if strategy.inited: # Double check within thread
            self.write_log(f"Init aborted: Strategy '{strategy_name}' was already initialized by another thread.", level=DEBUG, strategy=strategy)
            return
        self.write_log(f"Starting initialization process for: {strategy_name}", level=INFO, strategy=strategy)
        init_success = False
        try:
            self._load_single_strategy_data(strategy)
            if not self._subscribe_strategy_data(strategy):
                raise RuntimeError("Market data subscription failed.")
            if hasattr(strategy, 'on_init') and callable(strategy.on_init):
                self.write_log(f"Calling {strategy_name}.on_init()...", level=DEBUG, strategy=strategy)
                self.call_strategy_func(strategy, strategy.on_init)
                if not strategy.inited:
                     raise RuntimeError("Strategy on_init logic failed or did not set 'inited' flag.")
            else:
                 strategy.inited = True
                 self.write_log(f"Strategy '{strategy_name}' has no on_init method, marked as initialized after subscriptions.", level=DEBUG, strategy=strategy)
            init_success = True
            self.write_log(f"Strategy '{strategy_name}' initialized successfully.", level=INFO, strategy=strategy)
        except Exception as e:
             strategy.inited = False
             self.write_log(f"Initialization failed for strategy '{strategy_name}': {e}", level=ERROR, strategy=strategy)
             self._unsubscribe_strategy_data(strategy)
        finally:
             self.put_strategy_update_event(strategy)

    def _subscribe_strategy_data(self, strategy: StrategyTemplate) -> bool:
        """[Internal] Subscribe to market data required by the strategy."""
        self.write_log(f"Subscribing market data for '{strategy.strategy_name}': {strategy.vt_symbols}", level=DEBUG, strategy=strategy)
        all_subs_successful = True
        subscribed_count = 0
        if not strategy.vt_symbols:
             self.write_log(f"No vt_symbols defined for strategy '{strategy.strategy_name}'. Skipping subscription.", level=DEBUG, strategy=strategy)
             return True
        for vt_symbol in strategy.vt_symbols:
            contract = self.get_contract(vt_symbol)
            if not contract:
                self.write_log(f"Subscription failed for {vt_symbol}: Contract details not found.", level=ERROR, strategy=strategy)
                all_subs_successful = False; continue
            gateway_name = contract.gateway_name
            if not gateway_name:
                 self.write_log(f"Subscription failed for {vt_symbol}: Contract has no associated gateway name.", level=ERROR, strategy=strategy)
                 all_subs_successful = False; continue
            req = SubscribeRequest(symbol=contract.symbol, exchange=contract.exchange)
            try:
                self.write_log(f"Sending subscription request: {req} via gateway '{gateway_name}'", level=DEBUG, strategy=strategy)
                self.main_engine.subscribe(req, gateway_name)
                subscribed_count += 1
            except Exception as e:
                self.write_log(f"Subscription request failed for {vt_symbol} on gateway {gateway_name}: {e}", level=ERROR, strategy=strategy)
                all_subs_successful = False
        if subscribed_count > 0:
             self.write_log(f"Sent subscription requests for {subscribed_count}/{len(strategy.vt_symbols)} symbols for '{strategy.strategy_name}'.", level=INFO, strategy=strategy)
        if not all_subs_successful:
             self.write_log(f"One or more market data subscriptions failed for '{strategy.strategy_name}'. Check logs.", level=WARNING, strategy=strategy)
        return all_subs_successful

    def _unsubscribe_strategy_data(self, strategy: StrategyTemplate) -> None:
        """[Internal] Placeholder for unsubscribing market data for a strategy."""
        self.write_log(f"Note: Unsubscribing data for '{strategy.strategy_name}' relies on gateway behavior or manual intervention.", level=DEBUG)
        pass

    @virtual
    def start_strategy(self, strategy_name: str) -> None:
        """Start trading for an initialized strategy."""
        if strategy_name not in self.strategies:
            self.write_log(f"Start failed: Strategy '{strategy_name}' not found.", level=ERROR); return
        strategy = self.strategies[strategy_name]
        if not strategy.inited:
            self.write_log(f"Start failed: Strategy '{strategy_name}' must be initialized first.", level=WARNING, strategy=strategy); return
        if strategy.trading:
            self.write_log(f"Start ignored: Strategy '{strategy_name}' is already trading.", level=DEBUG, strategy=strategy); return
        self.write_log(f"Starting strategy: {strategy_name}", level=INFO, strategy=strategy)
        start_success = False
        try:
            if hasattr(strategy, 'on_start') and callable(strategy.on_start):
                self.write_log(f"Calling {strategy_name}.on_start()...", level=DEBUG, strategy=strategy)
                self.call_strategy_func(strategy, strategy.on_start)
                if strategy.trading: start_success = True
            else:
                strategy.trading = True; start_success = True
                self.write_log(f"Strategy '{strategy_name}' has no on_start method, marked as trading.", level=DEBUG, strategy=strategy)
            if start_success:
                self.write_log(f"Strategy '{strategy_name}' started successfully.", level=INFO, strategy=strategy)
            else:
                self.write_log(f"Strategy '{strategy_name}' failed to start (check logs for errors in on_start).", level=WARNING, strategy=strategy)
        except Exception as e:
             strategy.trading = False
             self.write_log(f"Unexpected error during start process for '{strategy_name}': {e}", level=ERROR, strategy=strategy)
        finally:
             self.put_strategy_update_event(strategy)

    @virtual
    def stop_strategy(self, strategy_name: str) -> None:
        """Stop trading for a strategy."""
        if strategy_name not in self.strategies:
            self.write_log(f"Stop failed: Strategy '{strategy_name}' not found.", level=ERROR); return
        strategy = self.strategies[strategy_name]
        if not strategy.trading:
            self.write_log(f"Stop ignored: Strategy '{strategy_name}' is already stopped.", level=DEBUG, strategy=strategy); return
        self.write_log(f"Stopping strategy: {strategy_name}...", level=INFO, strategy=strategy)
        strategy.trading = False
        try:
            self._cancel_strategy_orders(strategy)
            if hasattr(strategy, 'on_stop') and callable(strategy.on_stop):
                self.write_log(f"Calling {strategy_name}.on_stop()...", level=DEBUG, strategy=strategy)
                self.call_strategy_func(strategy, strategy.on_stop)
            self.save_strategy_data(strategy_name)
            self.write_log(f"Strategy '{strategy_name}' stopped successfully.", level=INFO, strategy=strategy)
        except Exception as e:
             self.write_log(f"Error during stop process for '{strategy_name}': {e}\n{traceback.format_exc()}", level=ERROR, strategy=strategy)
        finally:
            self.put_strategy_update_event(strategy)

    def _cancel_strategy_orders(self, strategy: StrategyTemplate) -> None:
        """[Internal] Cancel all active orders reported by a strategy."""
        strategy_name = strategy.strategy_name
        self.write_log(f"Cancelling active orders for strategy '{strategy_name}'...", level=DEBUG, strategy=strategy)
        if not (hasattr(strategy, 'get_active_order_ids') and callable(strategy.get_active_order_ids)):
            self.write_log(f"Cannot cancel orders: Strategy '{strategy_name}' does not implement get_active_order_ids().", level=WARNING, strategy=strategy); return
        try:
            active_order_ids: List[str] = strategy.get_active_order_ids()
            if not isinstance(active_order_ids, list):
                 self.write_log(f"Strategy '{strategy_name}' get_active_order_ids() did not return a list. Cannot cancel orders.", level=WARNING, strategy=strategy); return
        except Exception:
            self.write_log(f"Error calling get_active_order_ids() for strategy '{strategy_name}':\n{traceback.format_exc()}", level=ERROR, strategy=strategy); return
        if not active_order_ids:
            self.write_log(f"No active orders reported by strategy '{strategy_name}' to cancel.", level=DEBUG, strategy=strategy); return
        self.write_log(f"Strategy '{strategy_name}' reported {len(active_order_ids)} active order(s): {active_order_ids}. Attempting cancellation.", level=DEBUG, strategy=strategy)
        cancelled_count = 0
        for vt_orderid in list(active_order_ids): # Iterate over copy
            if not isinstance(vt_orderid, str):
                 self.write_log(f"Skipping invalid order ID from {strategy_name}: {vt_orderid}", level=WARNING, strategy=strategy); continue
            order = self.main_engine.get_order(vt_orderid)
            if order and order.is_active():
                try:
                    self.cancel_order(order) # Use engine's method which handles mode
                    cancelled_count += 1
                except Exception:
                    self.write_log(f"Failed to send cancel request for order {vt_orderid} (Strategy: {strategy_name}):\n{traceback.format_exc()}", level=ERROR, strategy=strategy)
        self.write_log(f"Sent cancel requests for {cancelled_count}/{len(active_order_ids)} active orders reported by '{strategy_name}'.", level=INFO, strategy=strategy)

    @virtual
    def init_all_strategies(self) -> None:
        """Initialize all strategy instances that are not already initialized."""
        self.write_log("Initializing all strategies...", level=INFO)
        strategy_names = list(self.strategies.keys())
        init_queued_count = 0
        for name in strategy_names:
            if name in self.strategies and not self.strategies[name].inited:
                self.init_strategy(name)
                init_queued_count += 1
        self.write_log(f"Queued initialization for {init_queued_count} strategies.", level=INFO)

    @virtual
    def start_all_strategies(self) -> None:
        """Start all strategy instances that are initialized but not trading."""
        self.write_log("Starting all initialized strategies...", level=INFO)
        strategy_names = list(self.strategies.keys())
        start_attempt_count = 0
        for name in strategy_names:
            if name in self.strategies:
                strategy = self.strategies[name]
                if strategy.inited and not strategy.trading:
                    self.start_strategy(name)
                    start_attempt_count += 1
        self.write_log(f"Attempted to start {start_attempt_count} initialized strategies.", level=INFO)

    @virtual
    def stop_all_strategies(self) -> None:
        """Stop all strategy instances that are currently trading."""
        self.write_log("Stopping all running strategies...", level=INFO)
        strategy_names = list(self.strategies.keys())
        stop_attempt_count = 0
        for name in strategy_names:
            if name in self.strategies and self.strategies[name].trading:
                self.stop_strategy(name)
                stop_attempt_count += 1
        self.write_log(f"Attempted to stop {stop_attempt_count} running strategies.", level=INFO)
        self.save_all_strategy_data()

    # --------------------------------
    # Event Processing Callbacks
    # --------------------------------
    def process_order_event(self, event: Event) -> None:
        """Process ORDER events: Forward to the relevant strategy instance."""
        order: OrderData = event.data
        if not isinstance(order, OrderData): return
        reference = getattr(order, 'reference', None)
        if not reference: return
        strategy = self.strategies.get(reference)
        if strategy and hasattr(strategy, 'on_order') and callable(strategy.on_order):
            self.call_strategy_func(strategy, strategy.on_order, order)

    def process_trade_event(self, event: Event) -> None:
        """Process TRADE events: Forward to the relevant strategy instance."""
        trade: TradeData = event.data
        if not isinstance(trade, TradeData): return
        reference = getattr(trade, 'reference', None)
        if not reference and self.portfolio_engine:
            reference = self.portfolio_engine.order_reference_map.get(trade.vt_orderid)
            if reference: trade.reference = reference
        if not reference: return
        strategy = self.strategies.get(reference)
        if strategy and hasattr(strategy, 'on_trade') and callable(strategy.on_trade):
            self.call_strategy_func(strategy, strategy.on_trade, trade)

    def process_factor_event(self, event: Event) -> None:
        """Process FACTOR events: Update cache and trigger `on_factor` for active strategies."""
        factor_data: Any = event.data
        if not isinstance(factor_data, dict):
            self.write_log(f"Ignoring factor event: Data is not a dictionary (Type: {type(factor_data)}).", level=WARNING); return
        if not factor_data:
            self.write_log("Ignoring factor event: Data dictionary is empty.", level=DEBUG); return

        self.write_log(f"Processing factor update: {list(factor_data.keys())}", level=DEBUG)
        self.latest_factors.update(factor_data)
        self.factor_update_time = self.get_current_datetime() # Use engine time

        active_strategies = [s for s in list(self.strategies.values()) if s.inited and s.trading]
        for strategy in active_strategies:
            if hasattr(strategy, 'on_factor') and callable(strategy.on_factor):
                order_reqs: Optional[List[OrderRequest]] = self.call_strategy_func(
                    strategy, strategy.on_factor, self.latest_factors
                )
                if isinstance(order_reqs, list):
                    for req in order_reqs:
                        if isinstance(req, OrderRequest):
                            self.send_order(strategy_name=strategy.strategy_name, req=req)
                        else:
                            self.write_log(f"Strategy '{strategy.strategy_name}' returned invalid item in on_factor list: {type(req)}", level=WARNING, strategy=strategy)
                elif order_reqs is not None:
                    self.write_log(f"Strategy '{strategy.strategy_name}' on_factor returned unexpected type: {type(order_reqs)}", level=WARNING, strategy=strategy)

    # --------------------------------
    # Order Submission and Cancellation (Via ExecutionAgent / Backtester)
    # --------------------------------
    @virtual
    def send_order(
            self,
            strategy_name: str,
            req: OrderRequest,
            lock: bool = False,
            net: bool = False
    ) -> List[str]:
        """
        Send an order request, handling live vs. backtesting modes.
        Sets the order reference to the strategy name.
        """
        strategy = self.strategies.get(strategy_name)
        req.reference = strategy_name

        log_msg = (f"Sending order: Ref={req.reference}, {req.vt_symbol} "
                   f"{req.direction} {req.type} {req.volume}@{req.price}")
        self.write_log(log_msg, level=INFO, strategy=strategy)

        if not all([req.vt_symbol, req.direction, req.type, req.volume is not None]):
             self.write_log(f"Order rejected: Missing required fields in OrderRequest: {req}", level=ERROR, strategy=strategy)
             return []

        if self.get_engine_type() == EngineType.BACKTESTING:
            try:
                vt_orderid = self.main_engine.send_order(req, gateway_name="BACKTESTING")
                self.write_log(f"Order submitted to Backtester. VT OrderID: {vt_orderid}", level=INFO, strategy=strategy)
                return [vt_orderid] if vt_orderid else []
            except AttributeError:
                 self.write_log("Backtesting Error: MainEngine does not have 'send_order' method.", level=ERROR); return []
            except Exception:
                 self.write_log(f"Exception during backtesting order submission:\n{traceback.format_exc()}", level=ERROR, strategy=strategy); return []
        else: # Live Trading
            try:
                vt_orderids: List[str] = self.execution_agent.send_order(req=req, lock=lock, net=net)
                if vt_orderids:
                    self.write_log(f"Order submitted via ExecutionAgent. VT OrderIDs: {vt_orderids}", level=INFO, strategy=strategy)
                    return vt_orderids
                else:
                    self.write_log("Order submission failed (ExecutionAgent returned empty list).", level=ERROR, strategy=strategy)
                    return []
            except Exception:
                self.write_log(f"Exception during order submission via ExecutionAgent:\n{traceback.format_exc()}", level=ERROR, strategy=strategy)
                return []

    @virtual
    def cancel_order(self, req: Union[CancelRequest, OrderData]) -> None:
        """Cancel an active order, handling live vs. backtesting modes."""
        cancel_req: Optional[CancelRequest] = None
        vt_orderid_log = "N/A"; strategy_ref_log = ""

        if isinstance(req, OrderData):
            vt_orderid_log = req.vt_orderid
            strategy_ref_log = f" (Ref: {req.reference})" if req.reference else ""
            if not req.is_active():
                 self.write_log(f"Cancel ignored: Order {vt_orderid_log} is already inactive.", level=DEBUG); return
            try: cancel_req = req.create_cancel_request()
            except Exception: self.write_log(f"Failed to create CancelRequest from OrderData (ID: {vt_orderid_log}):\n{traceback.format_exc()}", level=ERROR); return
        elif isinstance(req, CancelRequest):
            cancel_req = req; vt_orderid_log = req.vt_orderid
            order_data = self.main_engine.get_order(vt_orderid_log)
            if order_data and order_data.reference: strategy_ref_log = f" (Ref: {order_data.reference})"
        else:
            self.write_log(f"Invalid type passed to cancel_order: {type(req)}.", level=ERROR); return

        if not cancel_req: return

        self.write_log(f"Attempting cancellation for order ID: {vt_orderid_log}{strategy_ref_log}", level=INFO)

        if self.get_engine_type() == EngineType.BACKTESTING:
            try:
                self.main_engine.cancel_order(cancel_req, gateway_name="BACKTESTING")
                self.write_log(f"Cancel request sent to Backtester for order {vt_orderid_log}.", level=INFO)
            except AttributeError:
                 self.write_log("Backtesting Error: MainEngine does not have 'cancel_order' method.", level=ERROR)
            except Exception:
                 self.write_log(f"Exception during backtesting order cancellation (ID: {vt_orderid_log}):\n{traceback.format_exc()}", level=ERROR)
        else: # Live Trading
            try:
                self.execution_agent.cancel_order(cancel_req)
            except Exception:
                self.write_log(f"Exception during order cancellation via ExecutionAgent (ID: {vt_orderid_log}):\n{traceback.format_exc()}", level=ERROR)

    # --------------------------------
    # Utility Methods for Strategies
    # --------------------------------
    def get_contract(self, vt_symbol: str) -> Optional[ContractData]:
        """Get contract details from MainEngine."""
        return self.main_engine.get_contract(vt_symbol)

    def get_tick(self, vt_symbol: str) -> Optional[TickData]:
        """Get the latest tick data from MainEngine."""
        return self.main_engine.get_tick(vt_symbol)

    def get_bar(self, vt_symbol: str) -> Optional[BarData]:
        """Get the latest bar data from MainEngine (if available)."""
        return self.main_engine.get_bar(vt_symbol)

    def get_pricetick(self, strategy: StrategyTemplate, vt_symbol: str) -> Optional[float]:
        """Get the price tick (minimum price increment) for a contract."""
        contract = self.get_contract(vt_symbol)
        if contract:
            return contract.pricetick
        else:
            self.write_log(f"Failed to get pricetick for {vt_symbol}: Contract not found.", strategy=strategy, level=WARNING)
            return None

    def get_size(self, strategy: StrategyTemplate, vt_symbol: str) -> Optional[float]:
        """Get the contract size (multiplier)."""
        contract = self.get_contract(vt_symbol)
        if contract:
            return contract.size
        else:
            self.write_log(f"Failed to get size for {vt_symbol}: Contract not found.", strategy=strategy, level=WARNING)
            return None

    def get_engine_type(self) -> EngineType:
        """Return the current engine type (LIVE or BACKTESTING)."""
        if hasattr(self.main_engine, "engine_type"):
             return self.main_engine.engine_type
        return self.engine_type

    def get_current_datetime(self) -> datetime:
        """Get current datetime (UTC in live, backtest time in backtesting)."""
        if self.get_engine_type() == EngineType.BACKTESTING:
             dt = getattr(self.main_engine, "datetime", None)
             if dt and isinstance(dt, datetime):
                  return dt
             else:
                  self.write_log("Backtesting time not available via main_engine.datetime. Falling back to system time.", level=ERROR)
                  return datetime.now(timezone.utc)
        else:
             return datetime.now(timezone.utc)

    # --- Portfolio Data Accessors ---
    def get_portfolio_position(self, strategy_name: str, vt_symbol: str) -> float:
        """Get current position size for a symbol tracked by the PortfolioEngine."""
        if not self.portfolio_engine:
            self.write_log("Cannot get portfolio position: PortfolioEngine is disabled.", level=WARNING); return 0.0
        contract_result = self.portfolio_engine.contract_results.get((strategy_name, vt_symbol))
        return contract_result.last_pos if contract_result else 0.0

    def get_portfolio_entry_price(self, strategy_name: str, vt_symbol: str) -> float:
        """Get average entry price for the current position tracked by PortfolioEngine."""
        if not self.portfolio_engine:
            self.write_log("Cannot get entry price: PortfolioEngine is disabled.", level=WARNING); return 0.0
        contract_result = self.portfolio_engine.contract_results.get((strategy_name, vt_symbol))
        return contract_result.avg_price if contract_result else 0.0

    def get_portfolio_pnl(self, strategy_name: str, vt_symbol: str) -> Tuple[float, float, float]:
        """Get (Trading PnL, Holding PnL, Total PnL) tracked by PortfolioEngine."""
        if not self.portfolio_engine:
            self.write_log("Cannot get PnL: PortfolioEngine is disabled.", level=WARNING); return 0.0, 0.0, 0.0
        contract_result = self.portfolio_engine.contract_results.get((strategy_name, vt_symbol))
        if contract_result:
            return (contract_result.trading_pnl, contract_result.holding_pnl, contract_result.total_pnl)
        else:
            return 0.0, 0.0, 0.0

    def get_portfolio_total_pnl(self, strategy_name: str) -> float:
        """Get the aggregated Total PnL for the entire strategy portfolio."""
        if not self.portfolio_engine:
            self.write_log("Cannot get total PnL: PortfolioEngine is disabled.", level=WARNING); return 0.0
        portfolio_result = self.portfolio_engine.portfolio_results.get(strategy_name)
        return portfolio_result.total_pnl if portfolio_result else 0.0

    # --- Strategy Information Accessors ---
    def get_all_strategy_class_names(self) -> List[str]:
        """Return a list of names of all loaded strategy classes."""
        return list(self.strategy_classes.keys())

    def get_strategy_class_parameters(self, class_name: str) -> Optional[dict]:
        """Get the default parameters defined in a strategy class."""
        strategy_class = self.strategy_classes.get(class_name)
        if not strategy_class:
            self.write_log(f"Cannot get class parameters: Strategy class '{class_name}' not found.", level=ERROR); return None
        params = {}
        param_names = getattr(strategy_class, "parameters", [])
        for name in param_names:
            params[name] = getattr(strategy_class, name, None)
        return params

    def get_strategy_parameters(self, strategy_name: str) -> Optional[dict]:
        """Get the current parameters of a running strategy instance."""
        strategy = self.strategies.get(strategy_name)
        if not strategy:
            self.write_log(f"Cannot get parameters: Strategy instance '{strategy_name}' not found.", level=ERROR); return None
        if hasattr(strategy, 'get_parameters') and callable(strategy.get_parameters):
             return strategy.get_parameters()
        else:
             self.write_log(f"Strategy '{strategy_name}' does not implement get_parameters().", level=WARNING, strategy=strategy)
             return getattr(strategy, 'setting', None)

    # --------------------------------
    # Internal Helpers
    # --------------------------------
    def call_strategy_func(self, strategy: StrategyTemplate, func: Callable, params: Optional[Any] = None) -> Any:
        """Safely execute a method on a strategy instance, handling exceptions."""
        func_name = getattr(func, '__name__', 'unknown_function')
        try:
            if params is not None:
                return func(params)
            else:
                return func()
        except Exception:
            error_msg = (f"Strategy '{strategy.strategy_name}' encountered an exception in '{func_name}'. "
                         f"Stopping strategy to prevent further errors.\n{traceback.format_exc()}")
            self.write_log(error_msg, strategy=strategy, level=ERROR)
            if strategy.trading:
                 strategy.trading = False
                 self.put_strategy_update_event(strategy)
            return None

    def put_strategy_update_event(self, strategy: StrategyTemplate, removed: bool = False) -> None:
        """Publish an event notifying listeners of a strategy state change or removal."""
        try:
            data: dict
            if hasattr(strategy, 'get_data') and callable(strategy.get_data):
                data = strategy.get_data()
                if not isinstance(data, dict):
                     self.write_log(f"Strategy '{strategy.strategy_name}'.get_data() did not return dict. Sending minimal update.", level=WARNING, strategy=strategy)
                     data = {}
            else: data = {}
            data.update({
                "strategy_name": strategy.strategy_name,
                "class_name": strategy.__class__.__name__,
                "inited": getattr(strategy, 'inited', False),
                "trading": getattr(strategy, 'trading', False),
                "removed": removed
            })
            event = Event(type=EVENT_STRATEGY_UPDATE, data=data)
            self.event_engine.put(event)
        except Exception as e:
            self.write_log(f"Error preparing or putting strategy update event for '{strategy.strategy_name}': {e}", level=ERROR, strategy=strategy)

    @virtual
    def write_log(self, msg: str, strategy: Optional[StrategyTemplate] = None, level: int = INFO) -> None:
        """Write a log message, prefixing with source and pushing to vnpy event log."""
        prefix = f"[{strategy.strategy_name}]" if strategy else f"[{self.engine_name}]"
        log_entry = LogData(msg=f"{prefix} {msg}", gateway_name=self.engine_name, level=level)
        event = Event(type=EVENT_STRATEGY_LOG, data=log_entry)
        self.event_engine.put(event)

    def send_email(self, subject: str, msg: str, strategy: Optional[StrategyTemplate] = None) -> None:
        """Send an email notification through the MainEngine."""
        full_subject = f"[{strategy.strategy_name if strategy else self.engine_name}] {subject}"
        try:
            self.main_engine.send_email(full_subject, msg)
            self.write_log(f"Sent email notification: Subject: {full_subject}", level=INFO, strategy=strategy)
        except Exception:
            self.write_log(f"Failed to send email: Subject: {full_subject}\n{traceback.format_exc()}", level=ERROR, strategy=strategy)

