# -*- coding: utf-8 -*-
"""
Defines the BaseStrategyEngine, the core component for managing and executing
trading strategies within the vn.py framework. It integrates portfolio
management capabilities via an optional PortfolioEngine.

Core Responsibilities:
- Loading strategy code modules and configuration settings.
- Managing the lifecycle of strategy instances (initialization, start, stop).
- Subscribing to necessary market data for strategies.
- Processing market events (e.g., factor updates) and triggering strategy logic.
- Handling order requests generated by strategies via a dedicated ExecutionAgent.
- Routing order and trade update events back to the relevant strategy instances.
- Providing utility functions for strategies to access market data, contract details,
  and portfolio state (if PortfolioEngine is active).
- Persisting strategy settings and optional runtime state.
"""

import importlib
import traceback
import os
import sys
import glob
import re # For _camel_to_snake
import inspect # For checking abstract base classes
from typing import Type, Callable, Dict, List, Optional, Any, Tuple, Set, Union
from datetime import datetime, timezone, date
from concurrent.futures import ThreadPoolExecutor
from logging import INFO, ERROR, DEBUG, WARNING  # Standard logging levels
from pathlib import Path
# from types import ModuleType # No longer needed for _load_strategy_class_from_module

# --- VnTrader Core Imports ---
from vnpy.event import Event, EventEngine
from vnpy.strategy.base import EVENT_PORTFOLIO_STRATEGY
from vnpy.trader.engine import BaseEngine, MainEngine
from vnpy.trader.object import (
    OrderRequest, SubscribeRequest, CancelRequest,
    LogData, TickData, OrderData, TradeData, BarData, ContractData
)
from vnpy.trader.event import (
    EVENT_ORDER, EVENT_TRADE, EVENT_CONTRACT, EVENT_TIMER, EVENT_LOG,
    EVENT_FACTOR
)
from vnpy.trader.constant import EngineType
from vnpy.trader.utility import load_json, save_json, get_file_path, virtual
from vnpy.trader.database import BaseDatabase, get_database
from vnpy.trader.datafeed import BaseDatafeed, get_datafeed
from vnpy.strategy.settings import (
    get_strategy_instance_definitions_filepath, # Updated
    get_strategy_setting,
    STRATEGY_MODULE_SETTINGS
)
import pandas as pd # For DataFrame operations

# --- Strategy & Portfolio Specific Imports ---
# Assumes portfolio_manager is accessible (e.g., sibling directory or installed)
from vnpy.app.portfolio_manager.engine import PortfolioEngine, APP_NAME as PortfolioEngine_APP_NAME

PORTFOLIO_APP_NAME = PortfolioEngine_APP_NAME

from vnpy.strategy.execution_agent import ExecutionAgent
from vnpy.factor.memory import FactorMemory # Added
from vnpy.strategy.template import StrategyTemplate

# --- Constants ---
STRATEGY_ENGINE_APP_NAME: str = "StrategyEngine"  # Default unique name for this engine
# DEFAULT_STRATEGIES_DIR is now handled by STRATEGY_MODULE_SETTINGS
# DEFAULT_EXECUTION_GATEWAY is now handled by STRATEGY_MODULE_SETTINGS

# Filename Templates
# SETTING_FILENAME_TPL is replaced by definitions_filepath
STRATEGY_DATA_FILENAME_TPL: str = "strategy_data_{}.json"  # Template for strategy runtime data

# Event Types
EVENT_STRATEGY_LOG = EVENT_LOG  # Use standard log event type
EVENT_STRATEGY_UPDATE = EVENT_PORTFOLIO_STRATEGY  # Use standard strategy update event type


class BaseStrategyEngine(BaseEngine):
    """
    Core engine for loading, managing the lifecycle, and executing trading
    strategies derived from `StrategyTemplate`. Integrates with an optional
    `PortfolioEngine` for PnL and position tracking.
    """

    # Engine type can be overridden by MainEngine in backtesting mode
    engine_type: EngineType = EngineType.LIVE

    def __init__(
            self,
            main_engine: MainEngine,
            event_engine: EventEngine,
            engine_name: str = STRATEGY_ENGINE_APP_NAME
    ) -> None:
        """
        Initialize the BaseStrategyEngine.

        Args:
            main_engine: The main trading engine instance.
            event_engine: The central event engine instance.
            engine_name: A unique name for this engine instance.
        """
        super().__init__(main_engine, event_engine, engine_name=engine_name)

        # --- Load Configuration from Settings ---
        strategies_dir_default = "vnpy/strategy/examples"  # Default if not in settings
        strategies_dir_from_settings = STRATEGY_MODULE_SETTINGS.get("default_strategy_path", strategies_dir_default)
        self.strategies_path: Path = Path.cwd().joinpath(strategies_dir_from_settings)

        self.execution_gateway_name = STRATEGY_MODULE_SETTINGS.get("default_execution_gateway", "BINANCE_SPOT")
        
        # Use the new filepath for instance configurations
        self.definitions_filepath: Path = get_strategy_instance_definitions_filepath()

        self.write_log(f"Engine Name: {self.engine_name}", level=DEBUG)
        self.write_log(f"Strategies Code Directory: {self.strategies_path}", level=INFO)
        self.write_log(f"Execution Gateway: {self.execution_gateway_name}", level=INFO)
        self.write_log(f"Strategy Instance Definitions File: {self.definitions_filepath}", level=INFO) # Updated log

        # --- Core Strategy State ---
        self.strategy_classes: Dict[str, Type[StrategyTemplate]] = {}  # {ClassName: Class}
        self.strategies: Dict[str, StrategyTemplate] = {}  # {StrategyName: Instance}
        self.strategy_settings: Dict[str, dict] = {}  # {StrategyName: SettingDict} Loaded from file

        # --- Supporting Components ---
        self.database: BaseDatabase = get_database()
        self.datafeed: BaseDatafeed = get_datafeed()
        self.execution_agent: ExecutionAgent = self._init_execution_agent()
        self.portfolio_engine: Optional[PortfolioEngine] = self._init_portfolio_engine()

        # --- Asynchronous Operations ---
        self.init_executor: ThreadPoolExecutor = ThreadPoolExecutor(
            max_workers=1, thread_name_prefix=f"{self.engine_name}_Init"
        )

        # --- Factor Handling ---
        self.latest_factors: Dict[str, Any] = {} # Will be deprecated in process_factor_event
        self.factor_update_time: Optional[datetime] = None
        self.latest_factor_memories: Dict[str, "FactorMemory"] = {} # Added

        self.write_log("Engine initialization started.", level=DEBUG)

    def _init_execution_agent(self) -> ExecutionAgent:
        """Initialize the ExecutionAgent."""
        self.write_log(f"Initializing ExecutionAgent for gateway: {self.execution_gateway_name}", level=INFO)
        try:
            if not callable(ExecutionAgent) or ExecutionAgent.__name__ == 'object':  # Check if it's the dummy
                raise ImportError("ExecutionAgent class is not valid or not imported.")
            agent = ExecutionAgent(
                main_engine=self.main_engine,
                gateway_name=self.execution_gateway_name
            )
            self.write_log("ExecutionAgent initialized successfully.", level=INFO)
            return agent
        except Exception as e:
            self.write_log(f"FATAL: Failed to initialize ExecutionAgent: {e}\n{traceback.format_exc()}", level=ERROR)
            print(f"FATAL ERROR in {self.engine_name}: ExecutionAgent failed. Order functionality disabled.")

            class DummyExecutionAgent:
                def send_order(self, req: OrderRequest, lock: bool, net: bool) -> List[str]: self.log_error(
                    req); return []

                def cancel_order(self, req: Union[CancelRequest, OrderData]) -> None: self.log_error(req)

                def log_error(self, req): print(f"ERROR: ExecutionAgent not initialized. Cannot process request: {req}")

            return DummyExecutionAgent()

    def _init_portfolio_engine(self) -> Optional[PortfolioEngine]:
        """Initialize the PortfolioEngine if available."""
        if PortfolioEngine:  # Check if class was imported successfully
            self.write_log(f"Initializing PortfolioEngine ('{PORTFOLIO_APP_NAME}')...", level=INFO)
            try:
                portfolio_engine = PortfolioEngine(self.main_engine, self.event_engine)
                self.write_log(f"PortfolioEngine ('{PORTFOLIO_APP_NAME}') initialized successfully.", level=INFO)
                return portfolio_engine
            except Exception as e:
                self.write_log(f"Failed to initialize PortfolioEngine: {e}\n{traceback.format_exc()}", level=ERROR)
                return None
        else:
            self.write_log("PortfolioEngine class not available. Portfolio management disabled.", level=WARNING)
            return None

    # --------------------------------
    # Engine Lifecycle
    # --------------------------------

    def init_engine(self, *args, **kwargs) -> None:
        """Initialize the engine: Load components, strategies, settings, data, and register events."""
        self.write_log("Initializing Strategy Engine components...")
        try:
            self.init_datafeed()
            
            # Load configurations and instantiate strategies
            self.init_strategies_from_configs() # New unified method

            # Load persisted runtime data for the instantiated strategies
            self.load_all_strategy_data() 

            # if kwargs.get("strategies"): # This seems to be for external injection, review if still needed
            #     self.strategies = kwargs.get("strategies")

            self.register_event()
            self.write_log(f"{self.engine_name} initialization complete. "
                           f"{len(self.strategies)} strategies loaded. "
                           f"Portfolio Management: {'ENABLED' if self.portfolio_engine else 'DISABLED'}", level=INFO)
        except Exception as e:
            self.write_log(f"CRITICAL ERROR during engine initialization: {e}\n{traceback.format_exc()}", level=ERROR)

    def init_datafeed(self) -> None:
        """Initialize the data feed connection."""
        self.write_log("Initializing datafeed...", level=INFO)
        try:
            logger_callback = lambda msg: self.write_log(f"[DataFeed] {msg}", level=DEBUG)
            result: bool = self.datafeed.init(logger_callback)
            if result:
                self.write_log("Datafeed initialized successfully.", level=INFO)
            else:
                self.write_log("Datafeed initialization failed (returned False). Check datafeed logs.", level=WARNING)
        except Exception as e:
            self.write_log(f"Exception during datafeed initialization: {e}", level=ERROR)

    def register_event(self) -> None:
        """Register event listeners required by the StrategyEngine."""
        self.write_log("Registering engine event listeners...", level=DEBUG)
        try:
            self.event_engine.register(EVENT_ORDER, self.process_order_event)
            self.event_engine.register(EVENT_TRADE, self.process_trade_event)
            self.event_engine.register(EVENT_FACTOR, self.process_factor_event)
            self.event_engine.register(EVENT_TIMER, self._process_timer_event) # Added
            self.write_log("Engine event listeners registered.", level=DEBUG)
        except Exception as e:
            self.write_log(f"Error registering engine events: {e}", level=ERROR)

    def close(self) -> None:
        """Cleanly shut down the engine and its components."""
        self.write_log(f"Shutting down {self.engine_name}...")
        self.stop_all_strategies()
        if self.portfolio_engine:
            try:
                self.portfolio_engine.close()
                self.write_log(f"PortfolioEngine ('{PORTFOLIO_APP_NAME}') closed.", level=INFO)
            except Exception as e:
                self.write_log(f"Error closing PortfolioEngine: {e}\n{traceback.format_exc()}", level=ERROR)
        self.unregister_event()
        self.write_log("Shutting down init executor...", level=DEBUG)
        self.init_executor.shutdown(wait=True)
        self.write_log("Init executor shut down.", level=DEBUG)
        self.write_log(f"{self.engine_name} shut down complete.", level=INFO)

    def unregister_event(self) -> None:
        """Unregister event listeners used by the StrategyEngine."""
        self.write_log("Unregistering engine event listeners...", level=DEBUG)
        try:
            self.event_engine.unregister(EVENT_ORDER, self.process_order_event)
            self.event_engine.unregister(EVENT_TRADE, self.process_trade_event)
            self.event_engine.unregister(EVENT_FACTOR, self.process_factor_event)
            self.event_engine.unregister(EVENT_TIMER, self._process_timer_event) # Added
            self.write_log("Engine event listeners unregistered.", level=DEBUG)
        except Exception as e:
            self.write_log(f"Error unregistering engine events: {e}", level=ERROR)

    # --------------------------------
    # Strategy Loading and Settings
    # --------------------------------

    def _camel_to_snake(self, name: str) -> str:
        """Helper to convert CamelCase to snake_case for deriving module name."""
        s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
        return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()

    def _get_strategy_class(
        self,
        class_name: str,
        module_file_name: Optional[str] = None
    ) -> Optional[Type[StrategyTemplate]]:
        """
        Get a strategy class by its name, loading it from its module if necessary.
        Caches loaded classes in self.strategy_classes.
        """
        if class_name in self.strategy_classes:
            return self.strategy_classes[class_name]

        if module_file_name:
            # Ensure module_file_name does not contain path separators, only the file name.
            if os.path.sep in module_file_name or (os.altsep and os.altsep in module_file_name):
                self.write_log(f"Warning: module_file_name '{module_file_name}' should be a filename, not a path. Using basename.", level=WARNING)
                module_file_name = Path(module_file_name).name
            module_name_stem = Path(module_file_name).stem
        else:
            module_name_stem = self._camel_to_snake(class_name)
            self.write_log(f"Derived module name stem '{module_name_stem}' from class name '{class_name}'", level=DEBUG)

        # Construct module path for importlib
        # self.strategies_path is e.g. Path("vnpy/strategy/examples")
        # Python module path should be e.g. "vnpy.strategy.examples.my_strategy_module"
        
        # Convert self.strategies_path to a Python module path part
        # This requires finding the part of self.strategies_path that is relative to a directory in sys.path
        module_base_path_parts = []
        strategies_path_resolved = self.strategies_path.resolve()
        found_in_sys_path = False
        for p_str in sys.path:
            p_path = Path(p_str).resolve()
            try:
                if strategies_path_resolved.is_relative_to(p_path):
                    relative_parts = strategies_path_resolved.relative_to(p_path).parts
                    module_base_path_parts = list(relative_parts)
                    found_in_sys_path = True
                    break
            except ValueError: # Python < 3.9 Path.is_relative_to throws ValueError
                if str(strategies_path_resolved).startswith(str(p_path)):
                    relative_path_str = str(strategies_path_resolved.relative_to(p_path))
                    module_base_path_parts = list(Path(relative_path_str).parts)
                    found_in_sys_path = True
                    break
        
        if not found_in_sys_path:
            # Fallback: use the name of the strategies_path directory as the top-level package for strategies
            # This assumes parent of strategies_path is in sys.path
            self.write_log(f"Warning: Could not determine module base path for strategies relative to sys.path. "
                           f"Using strategies_path name '{self.strategies_path.name}' as module prefix.", level=WARNING)
            module_path_str = f"{self.strategies_path.name}.{module_name_stem}"
        else:
            if module_base_path_parts:
                 module_path_str = ".".join(module_base_path_parts) + f".{module_name_stem}"
            else: # strategies_path is directly in sys.path
                 module_path_str = module_name_stem


        strategy_file_on_disk = self.strategies_path.joinpath(f"{module_name_stem}.py")
        if not strategy_file_on_disk.exists():
            # Check if it's a package (directory with __init__.py)
            package_path_on_disk = self.strategies_path.joinpath(module_name_stem)
            if not (package_path_on_disk.is_dir() and package_path_on_disk.joinpath("__init__.py").exists()):
                self.write_log(f"Strategy file {strategy_file_on_disk} or package {package_path_on_disk} does not exist for module '{module_path_str}'.", level=ERROR)
                return None

        try:
            self.write_log(f"Attempting to import strategy module: {module_path_str}", level=DEBUG)
            module_to_load = importlib.import_module(module_path_str)
            module_to_load = importlib.reload(module_to_load) # Reload for development
            self.write_log(f"Successfully imported/reloaded module: {module_path_str}", level=DEBUG)

        except ImportError as e_import:
            self.write_log(f"Failed to import strategy module '{module_name_stem}' using path '{module_path_str}'. Error: {e_import}\n{traceback.format_exc()}", level=ERROR)
            return None
        except Exception as e_general:
            self.write_log(f"Unexpected error importing strategy module '{module_name_stem}' (Path: {module_path_str}): {e_general}\n{traceback.format_exc()}", level=ERROR)
            return None

        for item_name in dir(module_to_load):
            item_value = getattr(module_to_load, item_name)
            if (
                inspect.isclass(item_value)
                and item_value is not StrategyTemplate
                and issubclass(item_value, StrategyTemplate)
                and not inspect.isabstract(item_value) # Do not load abstract classes
            ):
                if item_value.__name__ == class_name:
                    self.strategy_classes[class_name] = item_value
                    self.write_log(f"Found and cached strategy class '{class_name}' from module '{module_path_str}'.", level=INFO)
                    return item_value
        
        self.write_log(f"Strategy class '{class_name}' not found in module '{module_path_str}'.", level=ERROR)
        return None

    def load_all_strategy_settings(self) -> None:
        """Load strategy instance configurations from the JSON file."""
        self.write_log(f"Loading strategy instance configurations from: {self.definitions_filepath}", level=INFO)
        
        # Expect a list of strategy instance configurations
        loaded_data: List[Dict[str, Any]] = load_json(self.definitions_filepath)
        
        current_settings: Dict[str, dict] = {}

        if isinstance(loaded_data, list):
            for i, instance_config in enumerate(loaded_data):
                if not isinstance(instance_config, dict):
                    self.write_log(f"Skipping invalid instance configuration (not a dict) at index {i}.", level=WARNING)
                    continue

                strategy_name = instance_config.get("strategy_name")
                if not strategy_name:
                    self.write_log(f"Skipping instance configuration at index {i} due to missing 'strategy_name'.", level=WARNING)
                    continue
                
                if strategy_name in current_settings:
                    self.write_log(f"Duplicate strategy_name '{strategy_name}' found in instance configurations. Previous entry will be overwritten.", level=WARNING)
                
                # Store the full instance configuration dictionary
                current_settings[strategy_name] = instance_config 
            
            self.strategy_settings = current_settings
            self.write_log(f"Loaded {len(self.strategy_settings)} strategy instance configurations.", level=INFO)

        elif loaded_data is None and not self.definitions_filepath.exists():
             self.write_log(f"Strategy instance definitions file {self.definitions_filepath} not found. Initializing with empty settings.", level=INFO)
             self.strategy_settings = {}
        else:
            self.write_log(
                f"Invalid data format in '{self.definitions_filepath}': Expected a list of strategy instance configurations, got {type(loaded_data)}. Initializing with empty settings.",
                level=ERROR)
            self.strategy_settings = {}


    def init_strategies_from_configs(self) -> None:
        """
        Loads strategy instance configurations and instantiates the strategies.
        This replaces the old create_strategies_from_settings method.
        """
        self.write_log("Initializing strategies from configurations...", level=INFO)
        
        # Step 1: Load Instance Configurations
        self.load_all_strategy_settings() # This populates self.strategy_settings

        # Step 2: Instantiate Strategies
        created_count = 0
        strategies_to_remove_from_settings = [] # If instantiation fails

        for strategy_name, instance_config_dict in self.strategy_settings.items():
            if not self._validate_setting_entry(strategy_name, instance_config_dict):
                strategies_to_remove_from_settings.append(strategy_name)
                continue

            class_name = instance_config_dict.get("class_name")
            module_file = instance_config_dict.get("module_file") # Optional, for specific file hint

            StrategyClass = self._get_strategy_class(class_name, module_file)

            if StrategyClass:
                try:
                    self.write_log(f"Instantiating strategy '{strategy_name}' from class '{class_name}'", level=DEBUG)
                    strategy_instance = StrategyClass(
                        strategy_engine=self,
                        strategy_name=strategy_name,
                        vt_symbols=instance_config_dict.get("vt_symbols", []),
                        setting=instance_config_dict, # Pass the whole dictionary
                        model_load_path=instance_config_dict.get("model_load_path"),
                        model_save_path=instance_config_dict.get("model_save_path"),
                        retraining_config=instance_config_dict.get("retraining_config", {}),
                        required_factor_keys=instance_config_dict.get("required_factor_keys", [])
                    )
                    self.strategies[strategy_name] = strategy_instance
                    # Note: update_strategy_setting_cache is implicitly handled as self.strategy_settings already holds the config.
                    # If strategy modifies its own config during init and it needs to be persisted, then an update would be needed.
                    self.write_log(f"Strategy instance '{strategy_name}' (Class: '{class_name}') created successfully.", level=INFO, strategy=strategy_instance)
                    self.put_strategy_update_event(strategy_instance) # Notify UI about new strategy
                    created_count +=1
                except Exception as e:
                    self.write_log(f"Failed to instantiate strategy '{strategy_name}' from class '{class_name}': {e}\n{traceback.format_exc()}", level=ERROR)
                    strategies_to_remove_from_settings.append(strategy_name)
            else:
                self.write_log(f"Strategy class '{class_name}' for instance '{strategy_name}' not found or failed to load. Skipping.", level=ERROR)
                strategies_to_remove_from_settings.append(strategy_name)
        
        if strategies_to_remove_from_settings:
            for name in strategies_to_remove_from_settings:
                self.strategy_settings.pop(name, None)
            self.write_log(f"Removed {len(strategies_to_remove_from_settings)} failed strategy configurations from runtime.", level=WARNING)

        self.write_log(f"Finished creating strategy instances. Successful: {created_count} of {len(self.strategy_settings) + len(strategies_to_remove_from_settings)} defined.", level=INFO)


    def _validate_setting_entry(self, strategy_name_key: str, instance_config: Any) -> bool:
        """Perform basic validation on a single strategy instance configuration entry."""
        if not isinstance(instance_config, dict):
            self.write_log(f"Invalid instance configuration for '{strategy_name_key}': Entry must be a dictionary.", level=WARNING)
            return False
        
        # Check for "strategy_name" inside the dictionary, and that it matches the key
        actual_strategy_name = instance_config.get("strategy_name")
        if not actual_strategy_name or not isinstance(actual_strategy_name, str):
             self.write_log(f"Invalid config for key '{strategy_name_key}': 'strategy_name' field missing or not a string within the config dict.", level=WARNING)
             return False
        if actual_strategy_name != strategy_name_key:
            self.write_log(f"Config mismatch for key '{strategy_name_key}': 'strategy_name' field ('{actual_strategy_name}') within dict does not match the key.", level=WARNING)
            return False

        # Validate essential fields in the instance_config
        required_fields = {
            "class_name": str, 
            # "vt_symbols": list, # vt_symbols is often optional at this stage, might be set later
            # "required_factor_keys": list, # Also can be optional or have defaults
            # "model_load_path": (str, type(None)), # Optional
            # "model_save_path": (str, type(None)), # Optional
            # "retraining_config": dict # Optional, defaults to {}
        }
        
        for field, expected_type in required_fields.items():
            if field not in instance_config:
                self.write_log(f"Invalid config for '{actual_strategy_name}': Missing required field '{field}'.", level=WARNING)
                return False
            if not isinstance(instance_config[field], expected_type): # type: ignore
                self.write_log(f"Invalid config for '{actual_strategy_name}': Field '{field}' has incorrect type. Expected {expected_type}, got {type(instance_config[field])}.", level=WARNING)
                return False
        
        class_name = instance_config["class_name"] # Already checked by required_fields
        # No need to check if class_name is in self.strategy_classes here, as _get_strategy_class will handle loading it.
        # _validate_setting_entry is called before class loading attempt.
            
        retraining_cfg = instance_config.get("retraining_config", {})
        if not isinstance(retraining_cfg, dict):
             self.write_log(f"Invalid config for '{actual_strategy_name}': 'retraining_config' must be a dictionary.", level=WARNING)
             return False
        if "frequency_days" in retraining_cfg and not isinstance(retraining_cfg.get("frequency_days"), (int, type(None))):
             self.write_log(f"Invalid retraining_config for '{actual_strategy_name}': 'frequency_days' must be an integer or null if present.", level=WARNING)
             return False

        return True

    def save_all_strategy_settings(self) -> None:
        """Save the current configuration of all active strategies to the instance definitions file."""
        self.write_log(f"Saving strategy instance configurations to: {self.definitions_filepath}", level=DEBUG)
        
        # settings_to_save will be a list of dictionaries
        settings_to_save: List[Dict[str, Any]] = [] 
        for strategy_name, strategy in self.strategies.items():
            try:
                # _get_strategy_setting_dict should return the full config dict for this instance
                instance_config_dict = self._get_strategy_setting_dict(strategy)
                settings_to_save.append(instance_config_dict)
            except Exception as e:
                self.write_log(f"Error preparing settings for strategy '{strategy_name}' for saving: {e}", level=ERROR,
                               strategy=strategy)

        if save_json(self.definitions_filepath, settings_to_save): # save_json expects data, not dict
            self.write_log(f"Saved configurations for {len(settings_to_save)} strategy instances to {self.definitions_filepath}", level=INFO)
        else:
            self.write_log(f"Failed to save strategy instance configurations to {self.definitions_filepath} (save_json returned False)", level=ERROR)

    def _get_strategy_setting_dict(self, strategy: StrategyTemplate) -> dict:
        """Create the dictionary representation of a strategy's instance configuration for saving."""
        if not hasattr(strategy, 'get_parameters') or not callable(strategy.get_parameters):
            raise AttributeError(f"Strategy '{strategy.strategy_name}' missing 'get_parameters' method.")
        
        # Get all parameters from the strategy (includes custom ones, model_config, trading_config etc.)
        current_params = strategy.get_parameters() 

        # Ensure standard fields required by the instance config structure are present
        # These should ideally be part of what get_parameters() returns if they are configurable.
        # If get_parameters() is well-implemented in StrategyTemplate, it should return all these.
        instance_config = {
            "strategy_name": strategy.strategy_name,
            "class_name": strategy.__class__.__name__,
            "vt_symbols": current_params.get("vt_symbols", strategy.vt_symbols), # Prefer from params, fallback to attr
            "required_factor_keys": current_params.get("required_factor_keys", strategy.required_factor_keys),
            "model_load_path": current_params.get("model_load_path", strategy.model_load_path),
            "model_save_path": current_params.get("model_save_path", strategy.model_save_path),
            "retrain_interval_days": current_params.get("retrain_interval_days", strategy.retrain_interval_days),
            "retraining_config": current_params.get("retraining_config", strategy.retraining_config),
            # model_config and trading_config are expected to be dicts within current_params
            "model_config": current_params.get("model_config", {}), # Or strategy.model_config.__dict__
            "trading_config": current_params.get("trading_config", {}) # Or strategy.trading_config.__dict__
        }
        
        # Add any other parameters that were part of the original 'setting' but not explicitly listed above
        # This assumes `get_parameters` returns everything that was in the initial `setting` dictionary
        # plus any dynamic state variables that are also considered "parameters".
        # We need to be careful not to just dump all attributes.
        # The `strategy.parameters` list (class attribute of StrategyTemplate) defines what `get_parameters` collects.
        # So, `current_params` should already contain all relevant items.
        
        # Merge remaining params from get_parameters() that are not already explicitly set.
        # This ensures custom parameters are included.
        for key, value in current_params.items():
            if key not in instance_config: # Avoid overwriting explicitly set standard fields
                instance_config[key] = value
        
        return instance_config

    def update_strategy_setting_cache(self, strategy_name: str) -> None:
        """Update the internal settings cache (self.strategy_settings) for a single strategy."""
        if strategy_name not in self.strategies:
            self.write_log(f"Cannot update settings cache: Strategy '{strategy_name}' not found.", level=ERROR)
            return
        strategy = self.strategies[strategy_name]
        try:
            # self.strategy_settings stores {strategy_name: full_instance_config_dict}
            self.strategy_settings[strategy_name] = self._get_strategy_setting_dict(strategy)
            self.write_log(f"Updated internal settings cache for strategy: {strategy_name}", level=DEBUG)
        except Exception as e:
            self.write_log(f"Error updating settings cache for strategy '{strategy_name}': {e}", level=ERROR,
                           strategy=strategy)

    def remove_strategy_setting_cache(self, strategy_name: str) -> None:
        """Remove a strategy's setting from the internal cache. Does NOT save to file."""
        if strategy_name in self.strategy_settings:
            if self.strategy_settings.pop(strategy_name, None):
                self.write_log(f"Removed setting for strategy '{strategy_name}' from internal cache.", level=DEBUG)

    # --------------------------------
    # Strategy Runtime Data Management
    # --------------------------------
    @virtual
    def load_all_strategy_data(self) -> None:
        """Load runtime data for all strategy instances that implement `load_data`."""
        self.write_log("Loading strategy runtime data...", level=INFO)
        loaded_count = 0
        for strategy_name in list(self.strategies.keys()):
            if strategy_name in self.strategies:
                strategy = self.strategies[strategy_name]
                if self._load_single_strategy_data(strategy):
                    loaded_count += 1
        self.write_log(f"Finished loading runtime data. Loaded for {loaded_count} strategies.", level=INFO)

    def _load_single_strategy_data(self, strategy: StrategyTemplate) -> bool:
        """Load runtime data for a single strategy instance if supported."""
        if not (hasattr(strategy, 'load_data') and callable(strategy.load_data)):
            return False
        strategy_name = strategy.strategy_name
        data_filename = STRATEGY_DATA_FILENAME_TPL.format(strategy_name)
        filepath = get_file_path(data_filename)
        if not filepath.exists():
            self.write_log(f"No runtime data file found for strategy: {strategy_name} at {filepath}", level=DEBUG,
                           strategy=strategy)
            return False
        try:
            strategy_data = load_json(filepath)
            if strategy_data:
                self.write_log(f"Attempting to load runtime data into strategy: {strategy_name}", level=DEBUG,
                               strategy=strategy)
                strategy.load_data(strategy_data)
                self.write_log(f"Successfully loaded runtime data for strategy: {strategy_name}", level=INFO,
                               strategy=strategy)
                return True
            else:
                self.write_log(f"Runtime data file for strategy {strategy_name} is empty or invalid JSON at {filepath}",
                               level=WARNING, strategy=strategy)
                return False
        except Exception:
            self.write_log(f"Error occurred within {strategy_name}.load_data() method:\n{traceback.format_exc()}",
                           level=ERROR, strategy=strategy)
            return False

    @virtual
    def save_strategy_data(self, strategy_name: str) -> bool:
        """Save runtime data for a specific strategy instance if supported."""
        if strategy_name not in self.strategies:
            self.write_log(f"Cannot save data: Strategy '{strategy_name}' not found.", level=ERROR)
            return False
        strategy = self.strategies[strategy_name]
        if not (hasattr(strategy, 'get_data') and callable(strategy.get_data)):
            self.write_log(f"Strategy '{strategy_name}' does not implement get_data(). Cannot save runtime data.",
                           level=DEBUG, strategy=strategy)
            return False
        data_filename = STRATEGY_DATA_FILENAME_TPL.format(strategy_name)
        filepath = get_file_path(data_filename)
        try:
            strategy_data = strategy.get_data()
            if not isinstance(strategy_data, dict):
                self.write_log(
                    f"Strategy '{strategy_name}' get_data() did not return a dictionary (returned {type(strategy_data)}). Cannot save.",
                    level=WARNING, strategy=strategy)
                return False
            self.write_log(f"Saving runtime data for strategy: {strategy_name} to {filepath}", level=DEBUG,
                           strategy=strategy)
            if save_json(filepath, strategy_data):
                return True
            else:
                self.write_log(f"Failed to save runtime data for strategy {strategy_name} (save_json returned False)",
                               level=ERROR, strategy=strategy)
                return False
        except Exception:
            self.write_log(f"Error occurred within {strategy_name}.get_data() method:\n{traceback.format_exc()}",
                           level=ERROR, strategy=strategy)
            return False

    def save_all_strategy_data(self) -> None:
        """Save runtime data for all active strategies that support it."""
        self.write_log("Saving runtime data for all strategies...", level=DEBUG)
        saved_count = 0
        for strategy_name in list(self.strategies.keys()):
            if strategy_name in self.strategies:
                if self.save_strategy_data(strategy_name):
                    saved_count += 1
        self.write_log(f"Finished saving runtime data. Saved for {saved_count} strategies.", level=INFO)

    # --------------------------------
    # Strategy Instance Management (Add, Edit, Remove)
    # --------------------------------
    def add_strategy(self, class_name: str, strategy_name: str, vt_symbols: List[str], setting: dict) -> bool:
        """Create, validate, and add a new strategy instance."""
        if not isinstance(strategy_name, str) or not strategy_name:
            self.write_log("Add failed: Strategy name must be a non-empty string.", level=ERROR)
            return False
        if strategy_name in self.strategies:
            self.write_log(f"Add failed: Strategy instance name '{strategy_name}' already exists.", level=ERROR)
            return False
        
        # 'setting' is the full instance_config_dict
        if not isinstance(setting, dict):
            self.write_log(f"Add failed for '{strategy_name}': Instance configuration (setting parameter) must be a dictionary.", level=ERROR)
            return False

        class_name = setting.get("class_name")
        if not class_name or not isinstance(class_name, str):
            self.write_log(f"Add failed for '{strategy_name}': 'class_name' missing or invalid in configuration.", level=ERROR)
            return False
            
        # module_file can be part of the setting dict to give a hint for loading
        module_file = setting.get("module_file") 
        StrategyClass = self._get_strategy_class(class_name, module_file)

        if not StrategyClass:
            self.write_log(f"Add failed for '{strategy_name}': Strategy class '{class_name}' could not be loaded.", level=ERROR)
            return False
        
        # vt_symbols is passed separately but should align with what's in setting or be primary
        if not isinstance(vt_symbols, list): 
            self.write_log(f"Add failed for '{strategy_name}': vt_symbols parameter must be a list.", level=ERROR)
            return False
        
        # Ensure vt_symbols in setting matches the passed vt_symbols if both exist, or update setting
        # For simplicity, assume vt_symbols param is authoritative for this call
        setting['vt_symbols'] = vt_symbols


        try:
            self.write_log(f"Instantiating strategy '{strategy_name}' from class '{class_name}' (runtime add).", level=DEBUG)
            strategy_instance = StrategyClass(
                strategy_engine=self,
                strategy_name=strategy_name,
                vt_symbols=vt_symbols,
                setting=setting, # Pass the full instance_config dictionary
                model_load_path=setting.get("model_load_path"),
                model_save_path=setting.get("model_save_path"),
                retraining_config=setting.get("retraining_config", {}),
                required_factor_keys=setting.get("required_factor_keys", [])
            )

            if not hasattr(strategy_instance, 'get_parameters') or not callable(strategy_instance.get_parameters):
                raise TypeError("Instantiated strategy object missing required 'get_parameters' method.")
            
        except Exception as e:
            self.write_log(
                f"Failed to instantiate strategy '{strategy_name}' from class '{class_name}' (runtime add): {e}\n{traceback.format_exc()}",
                level=ERROR)
            return False
            
        self.strategies[strategy_name] = strategy_instance
        # Update self.strategy_settings with the new strategy's configuration
        self.strategy_settings[strategy_name] = self._get_strategy_setting_dict(strategy_instance)
        # self.update_strategy_setting_cache(strategy_name) # This is effectively done by the line above + _get_strategy_setting_dict
        
        self.write_log(f"Strategy instance '{strategy_name}' (Class: '{class_name}') added successfully at runtime.", level=INFO,
                       strategy=strategy_instance)
        self.put_strategy_update_event(strategy_instance)
        return True

    def edit_strategy(self, strategy_name: str, new_instance_config: dict) -> bool:
        """Update parameters of an existing, stopped strategy instance. Saves settings."""
        if strategy_name not in self.strategies:
            self.write_log(f"Edit failed: Strategy instance '{strategy_name}' not found.", level=ERROR)
            return False
        strategy = self.strategies[strategy_name]
        if strategy.trading:
            self.write_log(f"Edit failed: Strategy '{strategy_name}' is currently running. Stop it before editing.",
                           level=WARNING, strategy=strategy)
            return False
        
        if not isinstance(new_instance_config, dict):
            self.write_log(f"Edit failed for '{strategy_name}': New instance configuration must be a dictionary.", level=ERROR)
            return False

        # Validate the new configuration before applying
        if not self._validate_setting_entry(strategy_name, new_instance_config):
            self.write_log(f"Edit failed for '{strategy_name}': New instance configuration is invalid.", level=WARNING)
            return False

        if not (hasattr(strategy, 'update_setting') and callable(strategy.update_setting)):
            self.write_log(
                f"Edit failed: Strategy class '{strategy.__class__.__name__}' does not implement 'update_setting'.",
                level=ERROR, strategy=strategy)
            return False
            
        try:
            self.write_log(f"Applying configuration updates to strategy '{strategy_name}'...", level=DEBUG,
                           strategy=strategy)
            # update_setting in StrategyTemplate should handle the full new_instance_config
            strategy.update_setting(new_instance_config) 
            
            # Update specific attributes like paths if they changed and are top-level on strategy
            # This should also be handled by strategy.update_setting if designed well.
            strategy.vt_symbols = new_instance_config.get("vt_symbols", strategy.vt_symbols)
            strategy.model_load_path = new_instance_config.get("model_load_path", strategy.model_load_path)
            strategy.model_save_path = new_instance_config.get("model_save_path", strategy.model_save_path)
            strategy.required_factor_keys = new_instance_config.get("required_factor_keys", strategy.required_factor_keys)
            strategy.retraining_config = new_instance_config.get("retraining_config", strategy.retraining_config)
            
            self.update_strategy_setting_cache(strategy_name) # This will call _get_strategy_setting_dict
            self.save_all_strategy_settings() # This will save the list of dicts
            self.write_log(
                f"Strategy '{strategy_name}' configuration updated and settings saved. Re-initialize the strategy to use new configuration.",
                level=INFO, strategy=strategy)
            self.put_strategy_update_event(strategy)
            return True
        except Exception:
            self.write_log(f"Error applying configuration update to strategy '{strategy_name}':\n{traceback.format_exc()}",
                           level=ERROR, strategy=strategy)
            return False

    def remove_strategy(self, strategy_name: str, remove_data_file: bool = False) -> bool:
        """Remove a stopped strategy instance. Saves settings. Optionally removes data."""
        if strategy_name not in self.strategies:
            self.write_log(f"Remove failed: Strategy '{strategy_name}' not found.", level=WARNING)
            return False
        strategy = self.strategies[strategy_name]
        if strategy.trading:
            self.write_log(f"Remove failed: Strategy '{strategy_name}' is currently running. Stop it first.",
                           level=ERROR, strategy=strategy)
            return False
        self.write_log(f"Removing strategy '{strategy_name}'...", level=INFO, strategy=strategy)
        if hasattr(strategy, 'on_stop') and callable(strategy.on_stop):
            self.write_log(f"Ensuring on_stop is called for '{strategy_name}' during removal.", level=DEBUG,
                           strategy=strategy)
            self.call_strategy_func(strategy, strategy.on_stop)
        removed_strategy = self.strategies.pop(strategy_name, None)
        if removed_strategy:
            self.remove_strategy_setting_cache(strategy_name)
            self.save_all_strategy_settings()
            if remove_data_file:
                data_filename = STRATEGY_DATA_FILENAME_TPL.format(strategy_name)
                filepath = get_file_path(data_filename)
                try:
                    if filepath.exists():
                        os.remove(filepath)
                        self.write_log(f"Removed runtime data file: {filepath}", level=INFO)
                except OSError as e:
                    self.write_log(f"Error removing runtime data file {filepath}: {e}", level=WARNING)
            self.put_strategy_update_event(removed_strategy, removed=True)
            self.write_log(f"Strategy '{strategy_name}' removed successfully.", level=INFO)
            return True
        else:
            self.write_log(f"Internal error during removal of strategy '{strategy_name}'.", level=ERROR)
            return False

    # --------------------------------
    # Strategy Lifecycle Control (Init, Start, Stop)
    # --------------------------------
    def init_strategy(self, strategy_name: str) -> None:
        """Asynchronously initialize a strategy instance."""
        if strategy_name not in self.strategies:
            self.write_log(f"Init request ignored: Strategy '{strategy_name}' not found.", level=ERROR)
            return
        strategy = self.strategies[strategy_name]
        if strategy.inited:
            self.write_log(f"Init request ignored: Strategy '{strategy_name}' is already initialized.", level=DEBUG,
                           strategy=strategy)
            return
        self.write_log(f"Queueing initialization for strategy: {strategy_name}", level=INFO, strategy=strategy)
        self.init_executor.submit(self._init_strategy_thread, strategy_name)

    def _init_strategy_thread(self, strategy_name: str) -> None:
        """[Internal] Worker thread function for initializing a single strategy."""
        if strategy_name not in self.strategies:
            self.write_log(f"Init aborted: Strategy '{strategy_name}' removed before initialization started.",
                           level=WARNING)
            return
        strategy = self.strategies[strategy_name]
        if strategy.inited:  # Double check within thread
            self.write_log(f"Init aborted: Strategy '{strategy_name}' was already initialized by another thread.",
                           level=DEBUG, strategy=strategy)
            return
        self.write_log(f"Starting initialization process for: {strategy_name}", level=INFO, strategy=strategy)
        init_success = False
        try:
            self._load_single_strategy_data(strategy)
            if not self._subscribe_strategy_data(strategy):
                raise RuntimeError("Market data subscription failed.")
            if hasattr(strategy, 'on_init') and callable(strategy.on_init):
                self.write_log(f"Calling {strategy_name}.on_init()...", level=DEBUG, strategy=strategy)
                self.call_strategy_func(strategy, strategy.on_init)
                if not strategy.inited:
                    raise RuntimeError("Strategy on_init logic failed or did not set 'inited' flag.")
            else:
                strategy.inited = True
                self.write_log(
                    f"Strategy '{strategy_name}' has no on_init method, marked as initialized after subscriptions.",
                    level=DEBUG, strategy=strategy)
            init_success = True
            self.write_log(f"Strategy '{strategy_name}' initialized successfully.", level=INFO, strategy=strategy)
        except Exception as e:
            strategy.inited = False
            self.write_log(f"Initialization failed for strategy '{strategy_name}': {e}", level=ERROR, strategy=strategy)
            self._unsubscribe_strategy_data(strategy)
        finally:
            self.put_strategy_update_event(strategy)

    def _subscribe_strategy_data(self, strategy: StrategyTemplate) -> bool:
        """[Internal] Subscribe to market data required by the strategy."""
        self.write_log(f"Subscribing market data for '{strategy.strategy_name}': {strategy.vt_symbols}", level=DEBUG,
                       strategy=strategy)
        all_subs_successful = True
        subscribed_count = 0
        if not strategy.vt_symbols:
            self.write_log(f"No vt_symbols defined for strategy '{strategy.strategy_name}'. Skipping subscription.",
                           level=DEBUG, strategy=strategy)
            return True
        for vt_symbol in strategy.vt_symbols:
            contract = self.get_contract(vt_symbol)
            if not contract:
                self.write_log(f"Subscription failed for {vt_symbol}: Contract details not found.", level=ERROR,
                               strategy=strategy)
                all_subs_successful = False;
                continue
            gateway_name = contract.gateway_name
            if not gateway_name:
                self.write_log(f"Subscription failed for {vt_symbol}: Contract has no associated gateway name.",
                               level=ERROR, strategy=strategy)
                all_subs_successful = False;
                continue
            req = SubscribeRequest(symbol=contract.symbol, exchange=contract.exchange)
            try:
                self.write_log(f"Sending subscription request: {req} via gateway '{gateway_name}'", level=DEBUG,
                               strategy=strategy)
                self.main_engine.subscribe(req, gateway_name)
                subscribed_count += 1
            except Exception as e:
                self.write_log(f"Subscription request failed for {vt_symbol} on gateway {gateway_name}: {e}",
                               level=ERROR, strategy=strategy)
                all_subs_successful = False
        if subscribed_count > 0:
            self.write_log(
                f"Sent subscription requests for {subscribed_count}/{len(strategy.vt_symbols)} symbols for '{strategy.strategy_name}'.",
                level=INFO, strategy=strategy)
        if not all_subs_successful:
            self.write_log(f"One or more market data subscriptions failed for '{strategy.strategy_name}'. Check logs.",
                           level=WARNING, strategy=strategy)
        return all_subs_successful

    def _unsubscribe_strategy_data(self, strategy: StrategyTemplate) -> None:
        """[Internal] Placeholder for unsubscribing market data for a strategy."""
        self.write_log(
            f"Note: Unsubscribing data for '{strategy.strategy_name}' relies on gateway behavior or manual intervention.",
            level=DEBUG)
        pass

    @virtual
    def start_strategy(self, strategy_name: str) -> None:
        """Start trading for an initialized strategy."""
        if strategy_name not in self.strategies:
            self.write_log(f"Start failed: Strategy '{strategy_name}' not found.", level=ERROR);
            return
        strategy = self.strategies[strategy_name]
        if not strategy.inited:
            self.write_log(f"Start failed: Strategy '{strategy_name}' must be initialized first.", level=WARNING,
                           strategy=strategy);
            return
        if strategy.trading:
            self.write_log(f"Start ignored: Strategy '{strategy_name}' is already trading.", level=DEBUG,
                           strategy=strategy);
            return
        self.write_log(f"Starting strategy: {strategy_name}", level=INFO, strategy=strategy)
        start_success = False
        try:
            if hasattr(strategy, 'on_start') and callable(strategy.on_start):
                self.write_log(f"Calling {strategy_name}.on_start()...", level=DEBUG, strategy=strategy)
                self.call_strategy_func(strategy, strategy.on_start)
                if strategy.trading: start_success = True
            else:
                strategy.trading = True;
                start_success = True
                self.write_log(f"Strategy '{strategy_name}' has no on_start method, marked as trading.", level=DEBUG,
                               strategy=strategy)
            if start_success:
                self.write_log(f"Strategy '{strategy_name}' started successfully.", level=INFO, strategy=strategy)
            else:
                self.write_log(f"Strategy '{strategy_name}' failed to start (check logs for errors in on_start).",
                               level=WARNING, strategy=strategy)
        except Exception as e:
            strategy.trading = False
            self.write_log(f"Unexpected error during start process for '{strategy_name}': {e}", level=ERROR,
                           strategy=strategy)
        finally:
            self.put_strategy_update_event(strategy)

    @virtual
    def stop_strategy(self, strategy_name: str) -> None:
        """Stop trading for a strategy."""
        if strategy_name not in self.strategies:
            self.write_log(f"Stop failed: Strategy '{strategy_name}' not found.", level=ERROR);
            return
        strategy = self.strategies[strategy_name]
        if not strategy.trading:
            self.write_log(f"Stop ignored: Strategy '{strategy_name}' is already stopped.", level=DEBUG,
                           strategy=strategy);
            return
        self.write_log(f"Stopping strategy: {strategy_name}...", level=INFO, strategy=strategy)
        strategy.trading = False
        try:
            self._cancel_strategy_orders(strategy)
            if hasattr(strategy, 'on_stop') and callable(strategy.on_stop):
                self.write_log(f"Calling {strategy_name}.on_stop()...", level=DEBUG, strategy=strategy)
                self.call_strategy_func(strategy, strategy.on_stop)
            self.save_strategy_data(strategy_name)
            self.write_log(f"Strategy '{strategy_name}' stopped successfully.", level=INFO, strategy=strategy)
        except Exception as e:
            self.write_log(f"Error during stop process for '{strategy_name}': {e}\n{traceback.format_exc()}",
                           level=ERROR, strategy=strategy)
        finally:
            self.put_strategy_update_event(strategy)

    def _cancel_strategy_orders(self, strategy: StrategyTemplate) -> None:
        """[Internal] Cancel all active orders reported by a strategy."""
        strategy_name = strategy.strategy_name
        self.write_log(f"Cancelling active orders for strategy '{strategy_name}'...", level=DEBUG, strategy=strategy)
        if not (hasattr(strategy, 'get_active_order_ids') and callable(strategy.get_active_order_ids)):
            self.write_log(
                f"Cannot cancel orders: Strategy '{strategy_name}' does not implement get_active_order_ids().",
                level=WARNING, strategy=strategy);
            return
        try:
            active_order_ids: List[str] = strategy.get_active_order_ids()
            if not isinstance(active_order_ids, list):
                self.write_log(
                    f"Strategy '{strategy_name}' get_active_order_ids() did not return a list. Cannot cancel orders.",
                    level=WARNING, strategy=strategy);
                return
        except Exception:
            self.write_log(
                f"Error calling get_active_order_ids() for strategy '{strategy_name}':\n{traceback.format_exc()}",
                level=ERROR, strategy=strategy);
            return
        if not active_order_ids:
            self.write_log(f"No active orders reported by strategy '{strategy_name}' to cancel.", level=DEBUG,
                           strategy=strategy);
            return
        self.write_log(
            f"Strategy '{strategy_name}' reported {len(active_order_ids)} active order(s): {active_order_ids}. Attempting cancellation.",
            level=DEBUG, strategy=strategy)
        cancelled_count = 0
        for vt_orderid in list(active_order_ids):  # Iterate over copy
            if not isinstance(vt_orderid, str):
                self.write_log(f"Skipping invalid order ID from {strategy_name}: {vt_orderid}", level=WARNING,
                               strategy=strategy);
                continue
            order = self.main_engine.get_order(vt_orderid)
            if order and order.is_active():
                try:
                    self.cancel_order(order)  # Use engine's method which handles mode
                    cancelled_count += 1
                except Exception:
                    self.write_log(
                        f"Failed to send cancel request for order {vt_orderid} (Strategy: {strategy_name}):\n{traceback.format_exc()}",
                        level=ERROR, strategy=strategy)
        self.write_log(
            f"Sent cancel requests for {cancelled_count}/{len(active_order_ids)} active orders reported by '{strategy_name}'.",
            level=INFO, strategy=strategy)

    @virtual
    def init_all_strategies(self) -> None:
        """Initialize all strategy instances that are not already initialized."""
        self.write_log("Initializing all strategies...", level=INFO)
        strategy_names = list(self.strategies.keys())
        init_queued_count = 0
        for name in strategy_names:
            if name in self.strategies and not self.strategies[name].inited:
                self.init_strategy(name)
                init_queued_count += 1
        self.write_log(f"Queued initialization for {init_queued_count} strategies.", level=INFO)

    @virtual
    def start_all_strategies(self) -> None:
        """Start all strategy instances that are initialized but not trading."""
        self.write_log("Starting all initialized strategies...", level=INFO)
        strategy_names = list(self.strategies.keys())
        start_attempt_count = 0
        for name in strategy_names:
            if name in self.strategies:
                strategy = self.strategies[name]
                if strategy.inited and not strategy.trading:
                    self.start_strategy(name)
                    start_attempt_count += 1
        self.write_log(f"Attempted to start {start_attempt_count} initialized strategies.", level=INFO)

    @virtual
    def stop_all_strategies(self) -> None:
        """Stop all strategy instances that are currently trading."""
        self.write_log("Stopping all running strategies...", level=INFO)
        strategy_names = list(self.strategies.keys())
        stop_attempt_count = 0
        for name in strategy_names:
            if name in self.strategies and self.strategies[name].trading:
                self.stop_strategy(name)
                stop_attempt_count += 1
        self.write_log(f"Attempted to stop {stop_attempt_count} running strategies.", level=INFO)
        self.save_all_strategy_data()

    # --------------------------------
    # Event Processing Callbacks
    # --------------------------------
    def process_order_event(self, event: Event) -> None:
        """Process ORDER events: Forward to the relevant strategy instance."""
        order: OrderData = event.data
        if not isinstance(order, OrderData): return
        reference = getattr(order, 'reference', None)
        if not reference: return
        strategy = self.strategies.get(reference)
        if strategy and hasattr(strategy, 'on_order') and callable(strategy.on_order):
            self.call_strategy_func(strategy, strategy.on_order, order)

    def process_trade_event(self, event: Event) -> None:
        """Process TRADE events: Forward to the relevant strategy instance."""
        trade: TradeData = event.data
        if not isinstance(trade, TradeData): return
        reference = getattr(trade, 'reference', None)
        if not reference and self.portfolio_engine:
            reference = self.portfolio_engine.order_reference_map.get(trade.vt_orderid)
            if reference: trade.reference = reference
        if not reference: return
        strategy = self.strategies.get(reference)
        if strategy and hasattr(strategy, 'on_trade') and callable(strategy.on_trade):
            self.call_strategy_func(strategy, strategy.on_trade, trade)

    def process_factor_event(self, event: Event) -> None:
        """Process FACTOR events: Update cache and trigger `on_factor` for active strategies."""
        factor_memories: Dict[str, "FactorMemory"] = event.data
        if not isinstance(factor_memories, dict):
            self.write_log(f"Ignoring factor event: Data is not a dictionary (Type: {type(factor_memories)}).",
                           level=WARNING)
            return
        if not factor_memories:
            self.write_log("Ignoring factor event: Data dictionary is empty.", level=DEBUG)
            return

        self.write_log(f"Processing factor update with FactorMemory objects: {list(factor_memories.keys())}", level=DEBUG)
        self.latest_factor_memories = factor_memories # Cache the received FactorMemory objects
        self.factor_update_time = self.get_current_datetime()  # Use engine time

        active_strategies = [s for s in list(self.strategies.values()) if s.inited and s.trading]
        for strategy in active_strategies:
            if hasattr(strategy, 'on_factor') and callable(strategy.on_factor):
                # Pass the entire dictionary of FactorMemory objects to the strategy
                order_reqs: Optional[List[OrderRequest]] = self.call_strategy_func(
                    strategy, strategy.on_factor, factor_memories
                )
                if isinstance(order_reqs, list):
                    for req in order_reqs:
                        if isinstance(req, OrderRequest):
                            self.send_order(strategy_name=strategy.strategy_name, req=req)
                        else:
                            self.write_log(
                                f"Strategy '{strategy.strategy_name}' returned invalid item in on_factor list: {type(req)}",
                                level=WARNING, strategy=strategy)
                elif order_reqs is not None:
                    self.write_log(
                        f"Strategy '{strategy.strategy_name}' on_factor returned unexpected type: {type(order_reqs)}",
                        level=WARNING, strategy=strategy)

    def _process_timer_event(self, event: Event) -> None:
        """Process TIMER events to check for strategy model retraining schedules."""
        current_datetime = self.get_current_datetime()

        # Iterate over a copy of strategy values if strategies dict could be modified
        for strategy in list(self.strategies.values()):
            if not (strategy.inited and strategy.trading):
                continue

            if not (hasattr(strategy, 'check_retraining_schedule') and callable(strategy.check_retraining_schedule)):
                # Ensure retrain_model exists as well, which is the method to be called.
                if not (hasattr(strategy, 'retrain_model') and callable(strategy.retrain_model)):
                    self.write_log(f"Strategy '{strategy.strategy_name}' has check_retraining_schedule but no retrain_model method. Skipping.", level=WARNING, strategy=strategy)
                    continue

                try:
                    if strategy.check_retraining_schedule(current_datetime):
                        self.write_log(f"Retraining condition met for strategy '{strategy.strategy_name}'. "
                                       f"Queueing model retraining.", level=INFO, strategy=strategy)
                        self.init_executor.submit(self._train_strategy_model_thread, strategy.strategy_name)
                except Exception as e:
                    self.write_log(f"Error during check_retraining_schedule for '{strategy.strategy_name}': {e}",
                                   level=ERROR, strategy=strategy)
            # else: # No check_retraining_schedule, so no scheduled retraining
                # self.write_log(f"Strategy {strategy.strategy_name} does not implement check_retraining_schedule.", DEBUG)


    def _train_strategy_model_thread(self, strategy_name: str) -> None:
        """
        [Internal] Worker thread function for orchestrating a single strategy's model retraining
        by calling its `retrain_model` method.
        """
        strategy = self.strategies.get(strategy_name)
        if not strategy:
            self.write_log(f"Model retraining aborted: Strategy '{strategy_name}' not found.", level=WARNING)
            return
        if not (strategy.inited and strategy.trading):
            self.write_log(f"Model retraining aborted for '{strategy_name}': Strategy no longer inited or trading.",
                           level=INFO, strategy=strategy)
            return
        
        if not (hasattr(strategy, 'retrain_model') and callable(strategy.retrain_model)):
            self.write_log(f"Cannot retrain model for '{strategy_name}': Strategy does not have a callable 'retrain_model' method.",
                           level=ERROR, strategy=strategy)
            return

        self.write_log(f"Starting model retraining process for strategy: {strategy_name} by calling strategy.retrain_model().",
                       level=INFO, strategy=strategy)
        
        try:
            # The strategy's retrain_model method is now responsible for all data fetching,
            # preparation, training, and saving the model.
            self.call_strategy_func(strategy, strategy.retrain_model) # No params needed from engine
            
            # Logging of success/failure and time updates should be handled within strategy.retrain_model()
            # and call_strategy_func will log exceptions if retrain_model fails.
            # We can add a generic completion log here.
            self.write_log(f"Strategy.retrain_model() call completed for '{strategy_name}'. "
                           f"Check strategy logs for details. Last retrained: {strategy.last_retrain_time}", 
                           level=INFO, strategy=strategy)

        except Exception as e: 
            # This is a fallback, call_strategy_func should already log the detailed exception.
            self.write_log(f"Exception during the call to {strategy_name}.retrain_model(): {e}", 
                           level=ERROR, strategy=strategy)
        
        # Update strategy state event as last_retrain_time might have changed
        self.put_strategy_update_event(strategy)


    # --------------------------------
    # Order Submission and Cancellation (Via ExecutionAgent / Backtester)
    # --------------------------------
    @virtual
    def send_order(
            self,
            strategy_name: str,
            req: OrderRequest,
            lock: bool = False,
            net: bool = False
    ) -> List[str]:
        """
        Send an order request, handling live vs. backtesting modes.
        Sets the order reference to the strategy name.
        """
        strategy = self.strategies.get(strategy_name)
        req.reference = strategy_name

        log_msg = (f"Sending order: Ref={req.reference}, {req.vt_symbol} "
                   f"{req.direction} {req.type} {req.volume}@{req.price}")
        self.write_log(log_msg, level=INFO, strategy=strategy)

        if not all([req.vt_symbol, req.direction, req.type, req.volume is not None]):
            self.write_log(f"Order rejected: Missing required fields in OrderRequest: {req}", level=ERROR,
                           strategy=strategy)
            return []

        if self.get_engine_type() == EngineType.BACKTESTING:
            try:
                vt_orderid = self.main_engine.send_order(req, gateway_name="BACKTESTING")
                self.write_log(f"Order submitted to Backtester. VT OrderID: {vt_orderid}", level=INFO,
                               strategy=strategy)
                return [vt_orderid] if vt_orderid else []
            except AttributeError:
                self.write_log("Backtesting Error: MainEngine does not have 'send_order' method.", level=ERROR);
                return []
            except Exception:
                self.write_log(f"Exception during backtesting order submission:\n{traceback.format_exc()}", level=ERROR,
                               strategy=strategy);
                return []
        else:  # Live Trading
            try:
                vt_orderids: List[str] = self.execution_agent.send_order(req=req, lock=lock, net=net)
                if vt_orderids:
                    self.write_log(f"Order submitted via ExecutionAgent. VT OrderIDs: {vt_orderids}", level=INFO,
                                   strategy=strategy)
                    return vt_orderids
                else:
                    self.write_log("Order submission failed (ExecutionAgent returned empty list).", level=ERROR,
                                   strategy=strategy)
                    return []
            except Exception:
                self.write_log(f"Exception during order submission via ExecutionAgent:\n{traceback.format_exc()}",
                               level=ERROR, strategy=strategy)
                return []

    @virtual
    def cancel_order(self, req: Union[CancelRequest, OrderData]) -> None:
        """Cancel an active order, handling live vs. backtesting modes."""
        cancel_req: Optional[CancelRequest] = None
        vt_orderid_log = "N/A";
        strategy_ref_log = ""

        if isinstance(req, OrderData):
            vt_orderid_log = req.vt_orderid
            strategy_ref_log = f" (Ref: {req.reference})" if req.reference else ""
            if not req.is_active():
                self.write_log(f"Cancel ignored: Order {vt_orderid_log} is already inactive.", level=DEBUG);
                return
            try:
                cancel_req = req.create_cancel_request()
            except Exception:
                self.write_log(
                    f"Failed to create CancelRequest from OrderData (ID: {vt_orderid_log}):\n{traceback.format_exc()}",
                    level=ERROR);
                return
        elif isinstance(req, CancelRequest):
            cancel_req = req;
            vt_orderid_log = req.vt_orderid
            order_data = self.main_engine.get_order(vt_orderid_log)
            if order_data and order_data.reference: strategy_ref_log = f" (Ref: {order_data.reference})"
        else:
            self.write_log(f"Invalid type passed to cancel_order: {type(req)}.", level=ERROR);
            return

        if not cancel_req: return

        self.write_log(f"Attempting cancellation for order ID: {vt_orderid_log}{strategy_ref_log}", level=INFO)

        if self.get_engine_type() == EngineType.BACKTESTING:
            try:
                self.main_engine.cancel_order(cancel_req, gateway_name="BACKTESTING")
                self.write_log(f"Cancel request sent to Backtester for order {vt_orderid_log}.", level=INFO)
            except AttributeError:
                self.write_log("Backtesting Error: MainEngine does not have 'cancel_order' method.", level=ERROR)
            except Exception:
                self.write_log(
                    f"Exception during backtesting order cancellation (ID: {vt_orderid_log}):\n{traceback.format_exc()}",
                    level=ERROR)
        else:  # Live Trading
            try:
                self.execution_agent.cancel_order(cancel_req)
            except Exception:
                self.write_log(
                    f"Exception during order cancellation via ExecutionAgent (ID: {vt_orderid_log}):\n{traceback.format_exc()}",
                    level=ERROR)

    # --------------------------------
    # Utility Methods for Strategies
    # --------------------------------
    def get_contract(self, vt_symbol: str) -> Optional[ContractData]:
        """Get contract details from MainEngine."""
        return self.main_engine.get_contract(vt_symbol)

    def get_tick(self, vt_symbol: str) -> Optional[TickData]:
        """Get the latest tick data from MainEngine."""
        return self.main_engine.get_tick(vt_symbol)

    def get_bar(self, vt_symbol: str) -> Optional[BarData]:
        """Get the latest bar data from MainEngine (if available)."""
        return self.main_engine.get_bar(vt_symbol)

    def get_pricetick(self, strategy: StrategyTemplate, vt_symbol: str) -> Optional[float]:
        """Get the price tick (minimum price increment) for a contract."""
        contract = self.get_contract(vt_symbol)
        if contract:
            return contract.pricetick
        else:
            self.write_log(f"Failed to get pricetick for {vt_symbol}: Contract not found.", strategy=strategy,
                           level=WARNING)
            return None

    def get_size(self, strategy: StrategyTemplate, vt_symbol: str) -> Optional[float]:
        """Get the contract size (multiplier)."""
        contract = self.get_contract(vt_symbol)
        if contract:
            return contract.size
        else:
            self.write_log(f"Failed to get size for {vt_symbol}: Contract not found.", strategy=strategy, level=WARNING)
            return None

    def get_engine_type(self) -> EngineType:
        """Return the current engine type (LIVE or BACKTESTING)."""
        if hasattr(self.main_engine, "engine_type"):
            return self.main_engine.engine_type
        return self.engine_type

    def get_current_datetime(self) -> datetime:
        """Get current datetime (UTC in live, backtest time in backtesting)."""
        if self.get_engine_type() == EngineType.BACKTESTING:
            dt = getattr(self.main_engine, "datetime", None)
            if dt and isinstance(dt, datetime):
                return dt
            else:
                self.write_log("Backtesting time not available via main_engine.datetime. Falling back to system time.",
                               level=ERROR)
                return datetime.now(timezone.utc)
        else:
            return datetime.now(timezone.utc)

    # --- Portfolio Data Accessors ---
    def get_portfolio_position(self, strategy_name: str, vt_symbol: str) -> float:
        """Get current position size for a symbol tracked by the PortfolioEngine."""
        if not self.portfolio_engine:
            self.write_log("Cannot get portfolio position: PortfolioEngine is disabled.", level=WARNING);
            return 0.0
        contract_result = self.portfolio_engine.contract_results.get((strategy_name, vt_symbol))
        return contract_result.last_pos if contract_result else 0.0

    def get_portfolio_entry_price(self, strategy_name: str, vt_symbol: str) -> float:
        """Get average entry price for the current position tracked by PortfolioEngine."""
        if not self.portfolio_engine:
            self.write_log("Cannot get entry price: PortfolioEngine is disabled.", level=WARNING);
            return 0.0
        contract_result = self.portfolio_engine.contract_results.get((strategy_name, vt_symbol))
        return contract_result.avg_price if contract_result else 0.0

    def get_portfolio_pnl(self, strategy_name: str, vt_symbol: str) -> Tuple[float, float, float]:
        """Get (Trading PnL, Holding PnL, Total PnL) tracked by PortfolioEngine."""
        if not self.portfolio_engine:
            self.write_log("Cannot get PnL: PortfolioEngine is disabled.", level=WARNING);
            return 0.0, 0.0, 0.0
        contract_result = self.portfolio_engine.contract_results.get((strategy_name, vt_symbol))
        if contract_result:
            return (contract_result.trading_pnl, contract_result.holding_pnl, contract_result.total_pnl)
        else:
            return 0.0, 0.0, 0.0

    def get_portfolio_total_pnl(self, strategy_name: str) -> float:
        """Get the aggregated Total PnL for the entire strategy portfolio."""
        if not self.portfolio_engine:
            self.write_log("Cannot get total PnL: PortfolioEngine is disabled.", level=WARNING);
            return 0.0
        portfolio_result = self.portfolio_engine.portfolio_results.get(strategy_name)
        return portfolio_result.total_pnl if portfolio_result else 0.0

    # --- Strategy Information Accessors ---
    def get_all_strategy_class_names(self) -> List[str]:
        """Return a list of names of all loaded strategy classes."""
        return list(self.strategy_classes.keys())

    def get_strategy_class_parameters(self, class_name: str) -> Optional[dict]:
        """Get the default parameters defined in a strategy class."""
        strategy_class = self.strategy_classes.get(class_name)
        if not strategy_class:
            self.write_log(f"Cannot get class parameters: Strategy class '{class_name}' not found.", level=ERROR);
            return None
        params = {}
        param_names = getattr(strategy_class, "parameters", [])
        for name in param_names:
            params[name] = getattr(strategy_class, name, None)
        return params

    def get_strategy_parameters(self, strategy_name: str) -> Optional[dict]:
        """Get the current parameters of a running strategy instance."""
        strategy = self.strategies.get(strategy_name)
        if not strategy:
            self.write_log(f"Cannot get parameters: Strategy instance '{strategy_name}' not found.", level=ERROR);
            return None
        if hasattr(strategy, 'get_parameters') and callable(strategy.get_parameters):
            return strategy.get_parameters()
        else:
            self.write_log(f"Strategy '{strategy_name}' does not implement get_parameters().", level=WARNING,
                           strategy=strategy)
            return getattr(strategy, 'setting', None)

    # --------------------------------
    # Internal Helpers
    # --------------------------------
    def call_strategy_func(self, strategy: StrategyTemplate, func: Callable, params: Optional[Any] = None) -> Any:
        """Safely execute a method on a strategy instance, handling exceptions."""
        func_name = getattr(func, '__name__', 'unknown_function')
        try:
            if params is not None:
                return func(params)
            else:
                return func()
        except Exception:
            error_msg = (f"Strategy '{strategy.strategy_name}' encountered an exception in '{func_name}'. "
                         f"Stopping strategy to prevent further errors.\n{traceback.format_exc()}")
            self.write_log(error_msg, strategy=strategy, level=ERROR)
            if strategy.trading:
                strategy.trading = False
                self.put_strategy_update_event(strategy)
            return None

    def put_strategy_update_event(self, strategy: StrategyTemplate, removed: bool = False) -> None:
        """Publish an event notifying listeners of a strategy state change or removal."""
        try:
            data: dict
            if hasattr(strategy, 'get_data') and callable(strategy.get_data):
                data = strategy.get_data()
                if not isinstance(data, dict):
                    self.write_log(
                        f"Strategy '{strategy.strategy_name}'.get_data() did not return dict. Sending minimal update.",
                        level=WARNING, strategy=strategy)
                    data = {}
            else:
                data = {}
            data.update({
                "strategy_name": strategy.strategy_name,
                "class_name": strategy.__class__.__name__,
                "inited": getattr(strategy, 'inited', False),
                "trading": getattr(strategy, 'trading', False),
                "removed": removed
            })
            event = Event(type=EVENT_STRATEGY_UPDATE, data=data)
            self.event_engine.put(event)
        except Exception as e:
            self.write_log(f"Error preparing or putting strategy update event for '{strategy.strategy_name}': {e}",
                           level=ERROR, strategy=strategy)

    @virtual
    def write_log(self, msg: str, strategy: Optional[StrategyTemplate] = None, level: int = INFO) -> None:
        """Write a log message, prefixing with source and pushing to vnpy event log."""
        prefix = f"[{strategy.strategy_name}] " if strategy else ""
        log_entry = LogData(msg=f"{prefix}{msg}", gateway_name=self.engine_name, level=level)
        event = Event(type=EVENT_STRATEGY_LOG, data=log_entry)
        self.event_engine.put(event)

    def send_email(self, subject: str, msg: str, strategy: Optional[StrategyTemplate] = None) -> None:
        """Send an email notification through the MainEngine."""
        full_subject = f"[{strategy.strategy_name if strategy else self.engine_name}] {subject}"
        try:
            self.main_engine.send_email(full_subject, msg)
            self.write_log(f"Sent email notification: Subject: {full_subject}", level=INFO, strategy=strategy)
        except Exception:
            self.write_log(f"Failed to send email: Subject: {full_subject}\n{traceback.format_exc()}", level=ERROR,
                           strategy=strategy)
